{"title":"singleflight简单介绍","date":"2024-06-24T07:56:16.000Z","toc":true,"source":"_posts/2024-06-24-singleflight简单介绍.md","raw":"---\ntitle: singleflight简单介绍\ndate: 2024-06-24 15:56:16\ntags: [组件分析]\ntoc: true\n---\n\n## 简单介绍\n\nsingleflight 包提供了一个抑制重复函数调用的机制。\n\nsingleflight 主要用于解决缓存击穿的问题。缓存击穿指的是热点数据不在缓存之中，表现为数据库收到大量查询请求，压力突增，性能下降。\n\nsingleflight 可以把相同的并发请求挂起，只保留一个请求去请求底层的数据库。当请求到结果的时候，给所有的并发请求返回同样的结果。\n\n![图片](singleflight1.png)\n\n## 基本流程\n\n### Demo\n\nsingleflight 的使用非常简单。singleflight 判断是否为同样请求的方法是调用内部函数时传入的 key 是否相同。\n\n下面的 Demo 模拟了 10 个同样的并发请求调用的场景。\n\n```Go\nconst key = \"same request\"\n\nfunc singleflightDemo() {\n\tvar wg sync.WaitGroup\n\tsfGroup := &singleflight.Group{}\n\tfor i := 0; i < 10; i++ {\n\t\twg.Add(1)\n\t\tgo func(idx int) {\n\t\t\tdefer wg.Done()\n\t\t\tval, err, _ := sfGroup.Do(key, func() (interface{}, error) {\n\t\t\t\tfmt.Printf(\"singleflight idx:%d, key:%s\\n\", idx, key)\n\t\t\t\t// 添加 sleep 可以延长单个请求的时间，保证其他请求都等到该请求结束才拿到结果\n\t\t\t\ttime.Sleep(10 * time.Millisecond)\n\t\t\t\treturn \"value\", nil\n\t\t\t})\n\t\t\tfmt.Printf(\"idx:%d, val:%v, err:%v\\n\", idx, val, err)\n\t\t}(i)\n\t}\n\twg.Wait()\n}\n```\n\n执行的结果如下：\n\n```shell\nsingleflight idx:9, key:same request\nidx:2, val:value, err:<nil>\nidx:6, val:value, err:<nil>\nidx:8, val:value, err:<nil>\nidx:5, val:value, err:<nil>\nidx:7, val:value, err:<nil>\nidx:1, val:value, err:<nil>\nidx:3, val:value, err:<nil>\nidx:9, val:value, err:<nil>\nidx:4, val:value, err:<nil>\nidx:0, val:value, err:<nil>\n```\n\n只有某一个协程请求到了内部函数，输出 `singleflight idx...`，其他的协程不会调用到内部函数。\n\n### 实现流程\n\nsingleflight 主要通过 sync. Mutex 和 sync. WaitGroup 来实现并发控制功能。\n\nGroup 结构体和 call 结构体如下所示：\n\n```Go\n// Group represents a class of work and forms a namespace in// which units of work can be executed with duplicate suppression.  \ntype Group struct {  \n\tmu sync.Mutex // protects m  \n\tm map[string]*call // lazily initialized  \n}\n\n// call is an in-flight or completed singleflight.Do call  \ntype call struct {  \n\twg sync.WaitGroup  \n  \n\t// These fields are written once before the WaitGroup is done  \n\t// and are only read after the WaitGroup is done.  \n\tval interface{}  \n\terr error  \n  \n\t// These fields are read and written with the singleflight  \n\t// mutex held before the WaitGroup is done, and are read but  \n\t// not written after the WaitGroup is done.  \n\tdups int  \n\tchans []chan<- Result  \n}\n```\n\n简单来说，singleflight 抑制并发请求的流程如下：\n\n- 当请求来到 singleflight 的时候，首先检查 m 中是否存在对应的 key\n- 如果存在\n  - 说明已经有函数正在请求底层数据库（即有 call 结构）\n  - 调用 Wait 方法，等待对应 call 的 WaitGroup 执行完成\n- 如果不存在\n  - 说明这是首次调用，封装一个新的 call\n  - 在 m 中插入对应的 key，执行底层函数\n- 执行完毕之后，把结果保存在 call 结构体中，调用 `wg.Done` 方法\n  - 其他调用从 call 中取出调用结果\n\n### 局限性\n\n- Do 方法是一个同步调用的方法，下游出现超时会导致服务阻塞\n\n解决方法是改用 DoChan 方法，并增加 select 来实现超时控制，保证在指定时间内可以拿到返回数据或者超时报错。\n\n- 某次调用恰好出现了错误或者阻塞，会导致所有调用都得到同样的错误\n\n可以通过 Forget 方法，定时删除 singleflight 的 Group 结构中记忆的 key，让其他的请求可以自行请求下游服务，开启一个新的 call 下游调用。\n\n## 组件分析\n\n### Do\n\n```Go\n// Do executes and returns the results of the given function, making// sure that only one execution is in-flight for a given key at a  \n// time. If a duplicate comes in, the duplicate caller waits for the  \n// original to complete and receives the same results.  \n// The return value shared indicates whether v was given to multiple callers.  \nfunc (g *Group) Do(key string, fn func() (interface{}, error)) (v interface{}, err error, shared bool) {  \n\tg.mu.Lock()  \n\tif g.m == nil {  \n\t\tg.m = make(map[string]*call)  \n\t}  \n\tif c, ok := g.m[key]; ok {  \n\t\tc.dups++  \n\t\tg.mu.Unlock()  \n\t\tc.wg.Wait()  \n\t\t  \n\t\tif e, ok := c.err.(*panicError); ok {  \n\t\t\tpanic(e)  \n\t\t} else if c.err == errGoexit {  \n\t\t\truntime.Goexit()  \n\t\t}  \n\t\treturn c.val, c.err, true  \n\t}  \n\tc := new(call)  \n\tc.wg.Add(1)  \n\tg.m[key] = c  \n\tg.mu.Unlock()  \n\t  \n\tg.doCall(c, key, fn)  \n\treturn c.val, c.err, c.dups > 0  \n\t}\n```\n\nDo 方法是 singleflight 最主要的调用方式，在上面的 Demo 里面也已经看到了使用的方法。\n\nDo 方法本身的逻辑非常简单，和上面的实现流程保持一致：\n\n- 如果当前 key 是第一个发起请求的协程，就新建一个 call 结构体，调用 doCall 方法来执行用户传入的 fn 函数\n- 如果当前 key 不是第一个发起请求的协程，就调用 `wg.Wait()` 方法，等待调用完毕之后，从 call 结构体中获取调用结果\n\n### DoChan\n\n```Go\n// DoChan is like Do but returns a channel that will receive the// results when they are ready.  \n//  \n// The returned channel will not be closed.  \nfunc (g *Group) DoChan(key string, fn func() (interface{}, error)) <-chan Result {  \n\tch := make(chan Result, 1)  \n\tg.mu.Lock()  \n\tif g.m == nil {  \n\t\tg.m = make(map[string]*call)  \n\t}  \n\tif c, ok := g.m[key]; ok {  \n\t\tc.dups++  \n\t\tc.chans = append(c.chans, ch)  \n\t\tg.mu.Unlock()  \n\t\treturn ch  \n\t}  \n\tc := &call{chans: []chan<- Result{ch}}  \n\tc.wg.Add(1)  \n\tg.m[key] = c  \n\tg.mu.Unlock()  \n\t  \n\tgo g.doCall(c, key, fn)  \n\t  \n\treturn ch  \n}\n```\n\nDoChan 方法和 Do 方法基本一致，区别在于 DoChan 是异步的版本，返回一个 chan 结构体，由用户自己等待来进行消费。\n\n### Forget\n\n```Go\n// Forget tells the singleflight to forget about a key. Future calls// to Do for this key will call the function rather than waiting for// an earlier call to complete.  \nfunc (g *Group) Forget(key string) {  \n\tg.mu.Lock()  \n\tdelete(g.m, key)  \n\tg.mu.Unlock()  \n}\n```\n\nForget 方法本身很短，就是把 Group 结构体中 m 对应的 key 删去，后续有同样的 key 的请求到来的时候，可以开启一个新的 call 调用下游函数。\n\n### doCall\n\n```Go\n// doCall handles the single call for a key.\nfunc (g *Group) doCall(c *call, key string, fn func() (interface{}, error)) {  \n\tnormalReturn := false  \n\trecovered := false  \n\t  \n\t// use double-defer to distinguish panic from runtime.Goexit,  \n\t// more details see https://golang.org/cl/134395  \n\tdefer func() {  \n\t\t// the given function invoked runtime.Goexit  \n\t\tif !normalReturn && !recovered {  \n\t\t\tc.err = errGoexit  \n\t\t}  \n\t  \n\t\tg.mu.Lock()  \n\t\tdefer g.mu.Unlock()  \n\t\tc.wg.Done()  \n\t\tif g.m[key] == c {  \n\t\t\tdelete(g.m, key)  \n\t\t}  \n\t  \n\t\tif e, ok := c.err.(*panicError); ok {  \n\t\t// In order to prevent the waiting channels from being blocked forever,  \n\t\t// needs to ensure that this panic cannot be recovered.  \n\t\t\tif len(c.chans) > 0 {  \n\t\t\t\tgo panic(e)  \n\t\t\t\tselect {} // Keep this goroutine around so that it will appear in the crash dump.  \n\t\t\t} else {  \n\t\t\t\tpanic(e)  \n\t\t\t}  \n\t\t} else if c.err == errGoexit {  \n\t\t\t// Already in the process of goexit, no need to call again  \n\t\t} else {  \n\t\t\t// Normal return  \n\t\t\tfor _, ch := range c.chans {  \n\t\t\t\tch <- Result{c.val, c.err, c.dups > 0}  \n\t\t\t}  \n\t\t}  \n\t}()  \n\t  \n\tfunc() {  \n\t\tdefer func() {  \n\t\t\tif !normalReturn {  \n\t// Ideally, we would wait to take a stack trace until we've determined  \n\t// whether this is a panic or a runtime.Goexit.  \n\t//  \n\t// Unfortunately, the only way we can distinguish the two is to see  \n\t// whether the recover stopped the goroutine from terminating, and by  \n\t// the time we know that, the part of the stack trace relevant to the  \n\t// panic has been discarded.  \n\t\t\tif r := recover(); r != nil {  \n\t\t\t\tc.err = newPanicError(r)  \n\t\t\t}  \n\t\t}  \n\t}()  \n\t  \n\tc.val, c.err = fn()  \n\t\tnormalReturn = true  \n\t}()  \n\t  \n\tif !normalReturn {  \n\t\trecovered = true  \n\t}  \n}\n```\n\ndoCall 函数会比较长，主要是为了保证即使 fn 函数出现了 panic 或者 `runtime.Exit` 之后的处理方式。\n\n在同步的情况下，出错之后可以在 Do 中进行统一处理；而在异步的情况下，处理被交给了业务方，所以 doCall 中直接引发 panic。\n\n### WaitGroup 的使用细节\n\n整体代码中有一个有趣的细节：一般 WaitGroup 的使用方式是主线程执行 Wait 方法，多个并发的线程在完成之后执行 Done 方法，主线程等待多个并发线程执行完毕。\n\n而在 Do 和 doCall 方法中，可以第一个执行的线程会执行 Done 方法，而多个并发线程则执行 Wait 来等待第一个执行线程的执行完毕。\n\n## 参考资料\n\n- [singleflight 官方文档](https://pkg.go.dev/golang.org/x/sync/singleflight#pkg-overview)\n- [深入理解Golang并发工具-Singleflight](https://juejin.cn/post/7093859835694809125#heading-0)\n","slug":"singleflight简单介绍","published":true,"updated":"2024-06-24T08:05:02.212Z","_id":"clxsp136n000xigw9fhth68yq","comments":true,"layout":"post","photos":[],"html":"<h2 id=\"简单介绍\"><a href=\"#简单介绍\" class=\"headerlink\" title=\"简单介绍\"></a>简单介绍</h2><p>singleflight 包提供了一个抑制重复函数调用的机制。</p>\n<p>singleflight 主要用于解决缓存击穿的问题。缓存击穿指的是热点数据不在缓存之中，表现为数据库收到大量查询请求，压力突增，性能下降。</p>\n<p>singleflight 可以把相同的并发请求挂起，只保留一个请求去请求底层的数据库。当请求到结果的时候，给所有的并发请求返回同样的结果。</p>\n<p><img src=\"/2024/06/24/singleflight%E7%AE%80%E5%8D%95%E4%BB%8B%E7%BB%8D/singleflight1.png\" alt=\"图片\"></p>\n<h2 id=\"基本流程\"><a href=\"#基本流程\" class=\"headerlink\" title=\"基本流程\"></a>基本流程</h2><h3 id=\"Demo\"><a href=\"#Demo\" class=\"headerlink\" title=\"Demo\"></a>Demo</h3><p>singleflight 的使用非常简单。singleflight 判断是否为同样请求的方法是调用内部函数时传入的 key 是否相同。</p>\n<p>下面的 Demo 模拟了 10 个同样的并发请求调用的场景。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> key = <span class=\"string\">&quot;same request&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">singleflightDemo</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">var</span> wg sync.WaitGroup</span><br><span class=\"line\">\tsfGroup := &amp;singleflight.Group&#123;&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> i := <span class=\"number\">0</span>; i &lt; <span class=\"number\">10</span>; i++ &#123;</span><br><span class=\"line\">\t\twg.Add(<span class=\"number\">1</span>)</span><br><span class=\"line\">\t\t<span class=\"keyword\">go</span> <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">(idx <span class=\"type\">int</span>)</span></span> &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">defer</span> wg.Done()</span><br><span class=\"line\">\t\t\tval, err, _ := sfGroup.Do(key, <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">()</span></span> (<span class=\"keyword\">interface</span>&#123;&#125;, <span class=\"type\">error</span>) &#123;</span><br><span class=\"line\">\t\t\t\tfmt.Printf(<span class=\"string\">&quot;singleflight idx:%d, key:%s\\n&quot;</span>, idx, key)</span><br><span class=\"line\">\t\t\t\t<span class=\"comment\">// 添加 sleep 可以延长单个请求的时间，保证其他请求都等到该请求结束才拿到结果</span></span><br><span class=\"line\">\t\t\t\ttime.Sleep(<span class=\"number\">10</span> * time.Millisecond)</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">return</span> <span class=\"string\">&quot;value&quot;</span>, <span class=\"literal\">nil</span></span><br><span class=\"line\">\t\t\t&#125;)</span><br><span class=\"line\">\t\t\tfmt.Printf(<span class=\"string\">&quot;idx:%d, val:%v, err:%v\\n&quot;</span>, idx, val, err)</span><br><span class=\"line\">\t\t&#125;(i)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\twg.Wait()</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>执行的结果如下：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">singleflight idx:9, key:same request</span><br><span class=\"line\">idx:2, val:value, err:&lt;nil&gt;</span><br><span class=\"line\">idx:6, val:value, err:&lt;nil&gt;</span><br><span class=\"line\">idx:8, val:value, err:&lt;nil&gt;</span><br><span class=\"line\">idx:5, val:value, err:&lt;nil&gt;</span><br><span class=\"line\">idx:7, val:value, err:&lt;nil&gt;</span><br><span class=\"line\">idx:1, val:value, err:&lt;nil&gt;</span><br><span class=\"line\">idx:3, val:value, err:&lt;nil&gt;</span><br><span class=\"line\">idx:9, val:value, err:&lt;nil&gt;</span><br><span class=\"line\">idx:4, val:value, err:&lt;nil&gt;</span><br><span class=\"line\">idx:0, val:value, err:&lt;nil&gt;</span><br></pre></td></tr></table></figure>\n\n<p>只有某一个协程请求到了内部函数，输出 <code>singleflight idx...</code>，其他的协程不会调用到内部函数。</p>\n<h3 id=\"实现流程\"><a href=\"#实现流程\" class=\"headerlink\" title=\"实现流程\"></a>实现流程</h3><p>singleflight 主要通过 sync. Mutex 和 sync. WaitGroup 来实现并发控制功能。</p>\n<p>Group 结构体和 call 结构体如下所示：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Group represents a class of work and forms a namespace in// which units of work can be executed with duplicate suppression.  </span></span><br><span class=\"line\"><span class=\"keyword\">type</span> Group <span class=\"keyword\">struct</span> &#123;  </span><br><span class=\"line\">\tmu sync.Mutex <span class=\"comment\">// protects m  </span></span><br><span class=\"line\">\tm <span class=\"keyword\">map</span>[<span class=\"type\">string</span>]*call <span class=\"comment\">// lazily initialized  </span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// call is an in-flight or completed singleflight.Do call  </span></span><br><span class=\"line\"><span class=\"keyword\">type</span> call <span class=\"keyword\">struct</span> &#123;  </span><br><span class=\"line\">\twg sync.WaitGroup  </span><br><span class=\"line\">  </span><br><span class=\"line\">\t<span class=\"comment\">// These fields are written once before the WaitGroup is done  </span></span><br><span class=\"line\">\t<span class=\"comment\">// and are only read after the WaitGroup is done.  </span></span><br><span class=\"line\">\tval <span class=\"keyword\">interface</span>&#123;&#125;  </span><br><span class=\"line\">\terr <span class=\"type\">error</span>  </span><br><span class=\"line\">  </span><br><span class=\"line\">\t<span class=\"comment\">// These fields are read and written with the singleflight  </span></span><br><span class=\"line\">\t<span class=\"comment\">// mutex held before the WaitGroup is done, and are read but  </span></span><br><span class=\"line\">\t<span class=\"comment\">// not written after the WaitGroup is done.  </span></span><br><span class=\"line\">\tdups <span class=\"type\">int</span>  </span><br><span class=\"line\">\tchans []<span class=\"keyword\">chan</span>&lt;- Result  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>简单来说，singleflight 抑制并发请求的流程如下：</p>\n<ul>\n<li>当请求来到 singleflight 的时候，首先检查 m 中是否存在对应的 key</li>\n<li>如果存在<ul>\n<li>说明已经有函数正在请求底层数据库（即有 call 结构）</li>\n<li>调用 Wait 方法，等待对应 call 的 WaitGroup 执行完成</li>\n</ul>\n</li>\n<li>如果不存在<ul>\n<li>说明这是首次调用，封装一个新的 call</li>\n<li>在 m 中插入对应的 key，执行底层函数</li>\n</ul>\n</li>\n<li>执行完毕之后，把结果保存在 call 结构体中，调用 <code>wg.Done</code> 方法<ul>\n<li>其他调用从 call 中取出调用结果</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"局限性\"><a href=\"#局限性\" class=\"headerlink\" title=\"局限性\"></a>局限性</h3><ul>\n<li>Do 方法是一个同步调用的方法，下游出现超时会导致服务阻塞</li>\n</ul>\n<p>解决方法是改用 DoChan 方法，并增加 select 来实现超时控制，保证在指定时间内可以拿到返回数据或者超时报错。</p>\n<ul>\n<li>某次调用恰好出现了错误或者阻塞，会导致所有调用都得到同样的错误</li>\n</ul>\n<p>可以通过 Forget 方法，定时删除 singleflight 的 Group 结构中记忆的 key，让其他的请求可以自行请求下游服务，开启一个新的 call 下游调用。</p>\n<h2 id=\"组件分析\"><a href=\"#组件分析\" class=\"headerlink\" title=\"组件分析\"></a>组件分析</h2><h3 id=\"Do\"><a href=\"#Do\" class=\"headerlink\" title=\"Do\"></a>Do</h3><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Do executes and returns the results of the given function, making// sure that only one execution is in-flight for a given key at a  </span></span><br><span class=\"line\"><span class=\"comment\">// time. If a duplicate comes in, the duplicate caller waits for the  </span></span><br><span class=\"line\"><span class=\"comment\">// original to complete and receives the same results.  </span></span><br><span class=\"line\"><span class=\"comment\">// The return value shared indicates whether v was given to multiple callers.  </span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(g *Group)</span></span> Do(key <span class=\"type\">string</span>, fn <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">()</span></span> (<span class=\"keyword\">interface</span>&#123;&#125;, <span class=\"type\">error</span>)) (v <span class=\"keyword\">interface</span>&#123;&#125;, err <span class=\"type\">error</span>, shared <span class=\"type\">bool</span>) &#123;  </span><br><span class=\"line\">\tg.mu.Lock()  </span><br><span class=\"line\">\t<span class=\"keyword\">if</span> g.m == <span class=\"literal\">nil</span> &#123;  </span><br><span class=\"line\">\t\tg.m = <span class=\"built_in\">make</span>(<span class=\"keyword\">map</span>[<span class=\"type\">string</span>]*call)  </span><br><span class=\"line\">\t&#125;  </span><br><span class=\"line\">\t<span class=\"keyword\">if</span> c, ok := g.m[key]; ok &#123;  </span><br><span class=\"line\">\t\tc.dups++  </span><br><span class=\"line\">\t\tg.mu.Unlock()  </span><br><span class=\"line\">\t\tc.wg.Wait()  </span><br><span class=\"line\">\t\t  </span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> e, ok := c.err.(*panicError); ok &#123;  </span><br><span class=\"line\">\t\t\t<span class=\"built_in\">panic</span>(e)  </span><br><span class=\"line\">\t\t&#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> c.err == errGoexit &#123;  </span><br><span class=\"line\">\t\t\truntime.Goexit()  </span><br><span class=\"line\">\t\t&#125;  </span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> c.val, c.err, <span class=\"literal\">true</span>  </span><br><span class=\"line\">\t&#125;  </span><br><span class=\"line\">\tc := <span class=\"built_in\">new</span>(call)  </span><br><span class=\"line\">\tc.wg.Add(<span class=\"number\">1</span>)  </span><br><span class=\"line\">\tg.m[key] = c  </span><br><span class=\"line\">\tg.mu.Unlock()  </span><br><span class=\"line\">\t  </span><br><span class=\"line\">\tg.doCall(c, key, fn)  </span><br><span class=\"line\">\t<span class=\"keyword\">return</span> c.val, c.err, c.dups &gt; <span class=\"number\">0</span>  </span><br><span class=\"line\">\t&#125;</span><br></pre></td></tr></table></figure>\n\n<p>Do 方法是 singleflight 最主要的调用方式，在上面的 Demo 里面也已经看到了使用的方法。</p>\n<p>Do 方法本身的逻辑非常简单，和上面的实现流程保持一致：</p>\n<ul>\n<li>如果当前 key 是第一个发起请求的协程，就新建一个 call 结构体，调用 doCall 方法来执行用户传入的 fn 函数</li>\n<li>如果当前 key 不是第一个发起请求的协程，就调用 <code>wg.Wait()</code> 方法，等待调用完毕之后，从 call 结构体中获取调用结果</li>\n</ul>\n<h3 id=\"DoChan\"><a href=\"#DoChan\" class=\"headerlink\" title=\"DoChan\"></a>DoChan</h3><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// DoChan is like Do but returns a channel that will receive the// results when they are ready.  </span></span><br><span class=\"line\"><span class=\"comment\">//  </span></span><br><span class=\"line\"><span class=\"comment\">// The returned channel will not be closed.  </span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(g *Group)</span></span> DoChan(key <span class=\"type\">string</span>, fn <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">()</span></span> (<span class=\"keyword\">interface</span>&#123;&#125;, <span class=\"type\">error</span>)) &lt;-<span class=\"keyword\">chan</span> Result &#123;  </span><br><span class=\"line\">\tch := <span class=\"built_in\">make</span>(<span class=\"keyword\">chan</span> Result, <span class=\"number\">1</span>)  </span><br><span class=\"line\">\tg.mu.Lock()  </span><br><span class=\"line\">\t<span class=\"keyword\">if</span> g.m == <span class=\"literal\">nil</span> &#123;  </span><br><span class=\"line\">\t\tg.m = <span class=\"built_in\">make</span>(<span class=\"keyword\">map</span>[<span class=\"type\">string</span>]*call)  </span><br><span class=\"line\">\t&#125;  </span><br><span class=\"line\">\t<span class=\"keyword\">if</span> c, ok := g.m[key]; ok &#123;  </span><br><span class=\"line\">\t\tc.dups++  </span><br><span class=\"line\">\t\tc.chans = <span class=\"built_in\">append</span>(c.chans, ch)  </span><br><span class=\"line\">\t\tg.mu.Unlock()  </span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> ch  </span><br><span class=\"line\">\t&#125;  </span><br><span class=\"line\">\tc := &amp;call&#123;chans: []<span class=\"keyword\">chan</span>&lt;- Result&#123;ch&#125;&#125;  </span><br><span class=\"line\">\tc.wg.Add(<span class=\"number\">1</span>)  </span><br><span class=\"line\">\tg.m[key] = c  </span><br><span class=\"line\">\tg.mu.Unlock()  </span><br><span class=\"line\">\t  </span><br><span class=\"line\">\t<span class=\"keyword\">go</span> g.doCall(c, key, fn)  </span><br><span class=\"line\">\t  </span><br><span class=\"line\">\t<span class=\"keyword\">return</span> ch  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>DoChan 方法和 Do 方法基本一致，区别在于 DoChan 是异步的版本，返回一个 chan 结构体，由用户自己等待来进行消费。</p>\n<h3 id=\"Forget\"><a href=\"#Forget\" class=\"headerlink\" title=\"Forget\"></a>Forget</h3><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Forget tells the singleflight to forget about a key. Future calls// to Do for this key will call the function rather than waiting for// an earlier call to complete.  </span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(g *Group)</span></span> Forget(key <span class=\"type\">string</span>) &#123;  </span><br><span class=\"line\">\tg.mu.Lock()  </span><br><span class=\"line\">\t<span class=\"built_in\">delete</span>(g.m, key)  </span><br><span class=\"line\">\tg.mu.Unlock()  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>Forget 方法本身很短，就是把 Group 结构体中 m 对应的 key 删去，后续有同样的 key 的请求到来的时候，可以开启一个新的 call 调用下游函数。</p>\n<h3 id=\"doCall\"><a href=\"#doCall\" class=\"headerlink\" title=\"doCall\"></a>doCall</h3><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// doCall handles the single call for a key.</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(g *Group)</span></span> doCall(c *call, key <span class=\"type\">string</span>, fn <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">()</span></span> (<span class=\"keyword\">interface</span>&#123;&#125;, <span class=\"type\">error</span>)) &#123;  </span><br><span class=\"line\">\tnormalReturn := <span class=\"literal\">false</span>  </span><br><span class=\"line\">\trecovered := <span class=\"literal\">false</span>  </span><br><span class=\"line\">\t  </span><br><span class=\"line\">\t<span class=\"comment\">// use double-defer to distinguish panic from runtime.Goexit,  </span></span><br><span class=\"line\">\t<span class=\"comment\">// more details see https://golang.org/cl/134395  </span></span><br><span class=\"line\">\t<span class=\"keyword\">defer</span> <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">()</span></span> &#123;  </span><br><span class=\"line\">\t\t<span class=\"comment\">// the given function invoked runtime.Goexit  </span></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> !normalReturn &amp;&amp; !recovered &#123;  </span><br><span class=\"line\">\t\t\tc.err = errGoexit  </span><br><span class=\"line\">\t\t&#125;  </span><br><span class=\"line\">\t  </span><br><span class=\"line\">\t\tg.mu.Lock()  </span><br><span class=\"line\">\t\t<span class=\"keyword\">defer</span> g.mu.Unlock()  </span><br><span class=\"line\">\t\tc.wg.Done()  </span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> g.m[key] == c &#123;  </span><br><span class=\"line\">\t\t\t<span class=\"built_in\">delete</span>(g.m, key)  </span><br><span class=\"line\">\t\t&#125;  </span><br><span class=\"line\">\t  </span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> e, ok := c.err.(*panicError); ok &#123;  </span><br><span class=\"line\">\t\t<span class=\"comment\">// In order to prevent the waiting channels from being blocked forever,  </span></span><br><span class=\"line\">\t\t<span class=\"comment\">// needs to ensure that this panic cannot be recovered.  </span></span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> <span class=\"built_in\">len</span>(c.chans) &gt; <span class=\"number\">0</span> &#123;  </span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">go</span> <span class=\"built_in\">panic</span>(e)  </span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">select</span> &#123;&#125; <span class=\"comment\">// Keep this goroutine around so that it will appear in the crash dump.  </span></span><br><span class=\"line\">\t\t\t&#125; <span class=\"keyword\">else</span> &#123;  </span><br><span class=\"line\">\t\t\t\t<span class=\"built_in\">panic</span>(e)  </span><br><span class=\"line\">\t\t\t&#125;  </span><br><span class=\"line\">\t\t&#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> c.err == errGoexit &#123;  </span><br><span class=\"line\">\t\t\t<span class=\"comment\">// Already in the process of goexit, no need to call again  </span></span><br><span class=\"line\">\t\t&#125; <span class=\"keyword\">else</span> &#123;  </span><br><span class=\"line\">\t\t\t<span class=\"comment\">// Normal return  </span></span><br><span class=\"line\">\t\t\t<span class=\"keyword\">for</span> _, ch := <span class=\"keyword\">range</span> c.chans &#123;  </span><br><span class=\"line\">\t\t\t\tch &lt;- Result&#123;c.val, c.err, c.dups &gt; <span class=\"number\">0</span>&#125;  </span><br><span class=\"line\">\t\t\t&#125;  </span><br><span class=\"line\">\t\t&#125;  </span><br><span class=\"line\">\t&#125;()  </span><br><span class=\"line\">\t  </span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">()</span></span> &#123;  </span><br><span class=\"line\">\t\t<span class=\"keyword\">defer</span> <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">()</span></span> &#123;  </span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> !normalReturn &#123;  </span><br><span class=\"line\">\t<span class=\"comment\">// Ideally, we would wait to take a stack trace until we&#x27;ve determined  </span></span><br><span class=\"line\">\t<span class=\"comment\">// whether this is a panic or a runtime.Goexit.  </span></span><br><span class=\"line\">\t<span class=\"comment\">//  </span></span><br><span class=\"line\">\t<span class=\"comment\">// Unfortunately, the only way we can distinguish the two is to see  </span></span><br><span class=\"line\">\t<span class=\"comment\">// whether the recover stopped the goroutine from terminating, and by  </span></span><br><span class=\"line\">\t<span class=\"comment\">// the time we know that, the part of the stack trace relevant to the  </span></span><br><span class=\"line\">\t<span class=\"comment\">// panic has been discarded.  </span></span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> r := <span class=\"built_in\">recover</span>(); r != <span class=\"literal\">nil</span> &#123;  </span><br><span class=\"line\">\t\t\t\tc.err = newPanicError(r)  </span><br><span class=\"line\">\t\t\t&#125;  </span><br><span class=\"line\">\t\t&#125;  </span><br><span class=\"line\">\t&#125;()  </span><br><span class=\"line\">\t  </span><br><span class=\"line\">\tc.val, c.err = fn()  </span><br><span class=\"line\">\t\tnormalReturn = <span class=\"literal\">true</span>  </span><br><span class=\"line\">\t&#125;()  </span><br><span class=\"line\">\t  </span><br><span class=\"line\">\t<span class=\"keyword\">if</span> !normalReturn &#123;  </span><br><span class=\"line\">\t\trecovered = <span class=\"literal\">true</span>  </span><br><span class=\"line\">\t&#125;  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>doCall 函数会比较长，主要是为了保证即使 fn 函数出现了 panic 或者 <code>runtime.Exit</code> 之后的处理方式。</p>\n<p>在同步的情况下，出错之后可以在 Do 中进行统一处理；而在异步的情况下，处理被交给了业务方，所以 doCall 中直接引发 panic。</p>\n<h3 id=\"WaitGroup-的使用细节\"><a href=\"#WaitGroup-的使用细节\" class=\"headerlink\" title=\"WaitGroup 的使用细节\"></a>WaitGroup 的使用细节</h3><p>整体代码中有一个有趣的细节：一般 WaitGroup 的使用方式是主线程执行 Wait 方法，多个并发的线程在完成之后执行 Done 方法，主线程等待多个并发线程执行完毕。</p>\n<p>而在 Do 和 doCall 方法中，可以第一个执行的线程会执行 Done 方法，而多个并发线程则执行 Wait 来等待第一个执行线程的执行完毕。</p>\n<h2 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h2><ul>\n<li><a href=\"https://pkg.go.dev/golang.org/x/sync/singleflight#pkg-overview\">singleflight 官方文档</a></li>\n<li><a href=\"https://juejin.cn/post/7093859835694809125#heading-0\">深入理解Golang并发工具-Singleflight</a></li>\n</ul>\n","excerpt":"","more":"<h2 id=\"简单介绍\"><a href=\"#简单介绍\" class=\"headerlink\" title=\"简单介绍\"></a>简单介绍</h2><p>singleflight 包提供了一个抑制重复函数调用的机制。</p>\n<p>singleflight 主要用于解决缓存击穿的问题。缓存击穿指的是热点数据不在缓存之中，表现为数据库收到大量查询请求，压力突增，性能下降。</p>\n<p>singleflight 可以把相同的并发请求挂起，只保留一个请求去请求底层的数据库。当请求到结果的时候，给所有的并发请求返回同样的结果。</p>\n<p><img src=\"/2024/06/24/singleflight%E7%AE%80%E5%8D%95%E4%BB%8B%E7%BB%8D/singleflight1.png\" alt=\"图片\"></p>\n<h2 id=\"基本流程\"><a href=\"#基本流程\" class=\"headerlink\" title=\"基本流程\"></a>基本流程</h2><h3 id=\"Demo\"><a href=\"#Demo\" class=\"headerlink\" title=\"Demo\"></a>Demo</h3><p>singleflight 的使用非常简单。singleflight 判断是否为同样请求的方法是调用内部函数时传入的 key 是否相同。</p>\n<p>下面的 Demo 模拟了 10 个同样的并发请求调用的场景。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> key = <span class=\"string\">&quot;same request&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">singleflightDemo</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">var</span> wg sync.WaitGroup</span><br><span class=\"line\">\tsfGroup := &amp;singleflight.Group&#123;&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> i := <span class=\"number\">0</span>; i &lt; <span class=\"number\">10</span>; i++ &#123;</span><br><span class=\"line\">\t\twg.Add(<span class=\"number\">1</span>)</span><br><span class=\"line\">\t\t<span class=\"keyword\">go</span> <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">(idx <span class=\"type\">int</span>)</span></span> &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">defer</span> wg.Done()</span><br><span class=\"line\">\t\t\tval, err, _ := sfGroup.Do(key, <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">()</span></span> (<span class=\"keyword\">interface</span>&#123;&#125;, <span class=\"type\">error</span>) &#123;</span><br><span class=\"line\">\t\t\t\tfmt.Printf(<span class=\"string\">&quot;singleflight idx:%d, key:%s\\n&quot;</span>, idx, key)</span><br><span class=\"line\">\t\t\t\t<span class=\"comment\">// 添加 sleep 可以延长单个请求的时间，保证其他请求都等到该请求结束才拿到结果</span></span><br><span class=\"line\">\t\t\t\ttime.Sleep(<span class=\"number\">10</span> * time.Millisecond)</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">return</span> <span class=\"string\">&quot;value&quot;</span>, <span class=\"literal\">nil</span></span><br><span class=\"line\">\t\t\t&#125;)</span><br><span class=\"line\">\t\t\tfmt.Printf(<span class=\"string\">&quot;idx:%d, val:%v, err:%v\\n&quot;</span>, idx, val, err)</span><br><span class=\"line\">\t\t&#125;(i)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\twg.Wait()</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>执行的结果如下：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">singleflight idx:9, key:same request</span><br><span class=\"line\">idx:2, val:value, err:&lt;nil&gt;</span><br><span class=\"line\">idx:6, val:value, err:&lt;nil&gt;</span><br><span class=\"line\">idx:8, val:value, err:&lt;nil&gt;</span><br><span class=\"line\">idx:5, val:value, err:&lt;nil&gt;</span><br><span class=\"line\">idx:7, val:value, err:&lt;nil&gt;</span><br><span class=\"line\">idx:1, val:value, err:&lt;nil&gt;</span><br><span class=\"line\">idx:3, val:value, err:&lt;nil&gt;</span><br><span class=\"line\">idx:9, val:value, err:&lt;nil&gt;</span><br><span class=\"line\">idx:4, val:value, err:&lt;nil&gt;</span><br><span class=\"line\">idx:0, val:value, err:&lt;nil&gt;</span><br></pre></td></tr></table></figure>\n\n<p>只有某一个协程请求到了内部函数，输出 <code>singleflight idx...</code>，其他的协程不会调用到内部函数。</p>\n<h3 id=\"实现流程\"><a href=\"#实现流程\" class=\"headerlink\" title=\"实现流程\"></a>实现流程</h3><p>singleflight 主要通过 sync. Mutex 和 sync. WaitGroup 来实现并发控制功能。</p>\n<p>Group 结构体和 call 结构体如下所示：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Group represents a class of work and forms a namespace in// which units of work can be executed with duplicate suppression.  </span></span><br><span class=\"line\"><span class=\"keyword\">type</span> Group <span class=\"keyword\">struct</span> &#123;  </span><br><span class=\"line\">\tmu sync.Mutex <span class=\"comment\">// protects m  </span></span><br><span class=\"line\">\tm <span class=\"keyword\">map</span>[<span class=\"type\">string</span>]*call <span class=\"comment\">// lazily initialized  </span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// call is an in-flight or completed singleflight.Do call  </span></span><br><span class=\"line\"><span class=\"keyword\">type</span> call <span class=\"keyword\">struct</span> &#123;  </span><br><span class=\"line\">\twg sync.WaitGroup  </span><br><span class=\"line\">  </span><br><span class=\"line\">\t<span class=\"comment\">// These fields are written once before the WaitGroup is done  </span></span><br><span class=\"line\">\t<span class=\"comment\">// and are only read after the WaitGroup is done.  </span></span><br><span class=\"line\">\tval <span class=\"keyword\">interface</span>&#123;&#125;  </span><br><span class=\"line\">\terr <span class=\"type\">error</span>  </span><br><span class=\"line\">  </span><br><span class=\"line\">\t<span class=\"comment\">// These fields are read and written with the singleflight  </span></span><br><span class=\"line\">\t<span class=\"comment\">// mutex held before the WaitGroup is done, and are read but  </span></span><br><span class=\"line\">\t<span class=\"comment\">// not written after the WaitGroup is done.  </span></span><br><span class=\"line\">\tdups <span class=\"type\">int</span>  </span><br><span class=\"line\">\tchans []<span class=\"keyword\">chan</span>&lt;- Result  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>简单来说，singleflight 抑制并发请求的流程如下：</p>\n<ul>\n<li>当请求来到 singleflight 的时候，首先检查 m 中是否存在对应的 key</li>\n<li>如果存在<ul>\n<li>说明已经有函数正在请求底层数据库（即有 call 结构）</li>\n<li>调用 Wait 方法，等待对应 call 的 WaitGroup 执行完成</li>\n</ul>\n</li>\n<li>如果不存在<ul>\n<li>说明这是首次调用，封装一个新的 call</li>\n<li>在 m 中插入对应的 key，执行底层函数</li>\n</ul>\n</li>\n<li>执行完毕之后，把结果保存在 call 结构体中，调用 <code>wg.Done</code> 方法<ul>\n<li>其他调用从 call 中取出调用结果</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"局限性\"><a href=\"#局限性\" class=\"headerlink\" title=\"局限性\"></a>局限性</h3><ul>\n<li>Do 方法是一个同步调用的方法，下游出现超时会导致服务阻塞</li>\n</ul>\n<p>解决方法是改用 DoChan 方法，并增加 select 来实现超时控制，保证在指定时间内可以拿到返回数据或者超时报错。</p>\n<ul>\n<li>某次调用恰好出现了错误或者阻塞，会导致所有调用都得到同样的错误</li>\n</ul>\n<p>可以通过 Forget 方法，定时删除 singleflight 的 Group 结构中记忆的 key，让其他的请求可以自行请求下游服务，开启一个新的 call 下游调用。</p>\n<h2 id=\"组件分析\"><a href=\"#组件分析\" class=\"headerlink\" title=\"组件分析\"></a>组件分析</h2><h3 id=\"Do\"><a href=\"#Do\" class=\"headerlink\" title=\"Do\"></a>Do</h3><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Do executes and returns the results of the given function, making// sure that only one execution is in-flight for a given key at a  </span></span><br><span class=\"line\"><span class=\"comment\">// time. If a duplicate comes in, the duplicate caller waits for the  </span></span><br><span class=\"line\"><span class=\"comment\">// original to complete and receives the same results.  </span></span><br><span class=\"line\"><span class=\"comment\">// The return value shared indicates whether v was given to multiple callers.  </span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(g *Group)</span></span> Do(key <span class=\"type\">string</span>, fn <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">()</span></span> (<span class=\"keyword\">interface</span>&#123;&#125;, <span class=\"type\">error</span>)) (v <span class=\"keyword\">interface</span>&#123;&#125;, err <span class=\"type\">error</span>, shared <span class=\"type\">bool</span>) &#123;  </span><br><span class=\"line\">\tg.mu.Lock()  </span><br><span class=\"line\">\t<span class=\"keyword\">if</span> g.m == <span class=\"literal\">nil</span> &#123;  </span><br><span class=\"line\">\t\tg.m = <span class=\"built_in\">make</span>(<span class=\"keyword\">map</span>[<span class=\"type\">string</span>]*call)  </span><br><span class=\"line\">\t&#125;  </span><br><span class=\"line\">\t<span class=\"keyword\">if</span> c, ok := g.m[key]; ok &#123;  </span><br><span class=\"line\">\t\tc.dups++  </span><br><span class=\"line\">\t\tg.mu.Unlock()  </span><br><span class=\"line\">\t\tc.wg.Wait()  </span><br><span class=\"line\">\t\t  </span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> e, ok := c.err.(*panicError); ok &#123;  </span><br><span class=\"line\">\t\t\t<span class=\"built_in\">panic</span>(e)  </span><br><span class=\"line\">\t\t&#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> c.err == errGoexit &#123;  </span><br><span class=\"line\">\t\t\truntime.Goexit()  </span><br><span class=\"line\">\t\t&#125;  </span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> c.val, c.err, <span class=\"literal\">true</span>  </span><br><span class=\"line\">\t&#125;  </span><br><span class=\"line\">\tc := <span class=\"built_in\">new</span>(call)  </span><br><span class=\"line\">\tc.wg.Add(<span class=\"number\">1</span>)  </span><br><span class=\"line\">\tg.m[key] = c  </span><br><span class=\"line\">\tg.mu.Unlock()  </span><br><span class=\"line\">\t  </span><br><span class=\"line\">\tg.doCall(c, key, fn)  </span><br><span class=\"line\">\t<span class=\"keyword\">return</span> c.val, c.err, c.dups &gt; <span class=\"number\">0</span>  </span><br><span class=\"line\">\t&#125;</span><br></pre></td></tr></table></figure>\n\n<p>Do 方法是 singleflight 最主要的调用方式，在上面的 Demo 里面也已经看到了使用的方法。</p>\n<p>Do 方法本身的逻辑非常简单，和上面的实现流程保持一致：</p>\n<ul>\n<li>如果当前 key 是第一个发起请求的协程，就新建一个 call 结构体，调用 doCall 方法来执行用户传入的 fn 函数</li>\n<li>如果当前 key 不是第一个发起请求的协程，就调用 <code>wg.Wait()</code> 方法，等待调用完毕之后，从 call 结构体中获取调用结果</li>\n</ul>\n<h3 id=\"DoChan\"><a href=\"#DoChan\" class=\"headerlink\" title=\"DoChan\"></a>DoChan</h3><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// DoChan is like Do but returns a channel that will receive the// results when they are ready.  </span></span><br><span class=\"line\"><span class=\"comment\">//  </span></span><br><span class=\"line\"><span class=\"comment\">// The returned channel will not be closed.  </span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(g *Group)</span></span> DoChan(key <span class=\"type\">string</span>, fn <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">()</span></span> (<span class=\"keyword\">interface</span>&#123;&#125;, <span class=\"type\">error</span>)) &lt;-<span class=\"keyword\">chan</span> Result &#123;  </span><br><span class=\"line\">\tch := <span class=\"built_in\">make</span>(<span class=\"keyword\">chan</span> Result, <span class=\"number\">1</span>)  </span><br><span class=\"line\">\tg.mu.Lock()  </span><br><span class=\"line\">\t<span class=\"keyword\">if</span> g.m == <span class=\"literal\">nil</span> &#123;  </span><br><span class=\"line\">\t\tg.m = <span class=\"built_in\">make</span>(<span class=\"keyword\">map</span>[<span class=\"type\">string</span>]*call)  </span><br><span class=\"line\">\t&#125;  </span><br><span class=\"line\">\t<span class=\"keyword\">if</span> c, ok := g.m[key]; ok &#123;  </span><br><span class=\"line\">\t\tc.dups++  </span><br><span class=\"line\">\t\tc.chans = <span class=\"built_in\">append</span>(c.chans, ch)  </span><br><span class=\"line\">\t\tg.mu.Unlock()  </span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> ch  </span><br><span class=\"line\">\t&#125;  </span><br><span class=\"line\">\tc := &amp;call&#123;chans: []<span class=\"keyword\">chan</span>&lt;- Result&#123;ch&#125;&#125;  </span><br><span class=\"line\">\tc.wg.Add(<span class=\"number\">1</span>)  </span><br><span class=\"line\">\tg.m[key] = c  </span><br><span class=\"line\">\tg.mu.Unlock()  </span><br><span class=\"line\">\t  </span><br><span class=\"line\">\t<span class=\"keyword\">go</span> g.doCall(c, key, fn)  </span><br><span class=\"line\">\t  </span><br><span class=\"line\">\t<span class=\"keyword\">return</span> ch  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>DoChan 方法和 Do 方法基本一致，区别在于 DoChan 是异步的版本，返回一个 chan 结构体，由用户自己等待来进行消费。</p>\n<h3 id=\"Forget\"><a href=\"#Forget\" class=\"headerlink\" title=\"Forget\"></a>Forget</h3><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Forget tells the singleflight to forget about a key. Future calls// to Do for this key will call the function rather than waiting for// an earlier call to complete.  </span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(g *Group)</span></span> Forget(key <span class=\"type\">string</span>) &#123;  </span><br><span class=\"line\">\tg.mu.Lock()  </span><br><span class=\"line\">\t<span class=\"built_in\">delete</span>(g.m, key)  </span><br><span class=\"line\">\tg.mu.Unlock()  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>Forget 方法本身很短，就是把 Group 结构体中 m 对应的 key 删去，后续有同样的 key 的请求到来的时候，可以开启一个新的 call 调用下游函数。</p>\n<h3 id=\"doCall\"><a href=\"#doCall\" class=\"headerlink\" title=\"doCall\"></a>doCall</h3><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// doCall handles the single call for a key.</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(g *Group)</span></span> doCall(c *call, key <span class=\"type\">string</span>, fn <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">()</span></span> (<span class=\"keyword\">interface</span>&#123;&#125;, <span class=\"type\">error</span>)) &#123;  </span><br><span class=\"line\">\tnormalReturn := <span class=\"literal\">false</span>  </span><br><span class=\"line\">\trecovered := <span class=\"literal\">false</span>  </span><br><span class=\"line\">\t  </span><br><span class=\"line\">\t<span class=\"comment\">// use double-defer to distinguish panic from runtime.Goexit,  </span></span><br><span class=\"line\">\t<span class=\"comment\">// more details see https://golang.org/cl/134395  </span></span><br><span class=\"line\">\t<span class=\"keyword\">defer</span> <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">()</span></span> &#123;  </span><br><span class=\"line\">\t\t<span class=\"comment\">// the given function invoked runtime.Goexit  </span></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> !normalReturn &amp;&amp; !recovered &#123;  </span><br><span class=\"line\">\t\t\tc.err = errGoexit  </span><br><span class=\"line\">\t\t&#125;  </span><br><span class=\"line\">\t  </span><br><span class=\"line\">\t\tg.mu.Lock()  </span><br><span class=\"line\">\t\t<span class=\"keyword\">defer</span> g.mu.Unlock()  </span><br><span class=\"line\">\t\tc.wg.Done()  </span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> g.m[key] == c &#123;  </span><br><span class=\"line\">\t\t\t<span class=\"built_in\">delete</span>(g.m, key)  </span><br><span class=\"line\">\t\t&#125;  </span><br><span class=\"line\">\t  </span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> e, ok := c.err.(*panicError); ok &#123;  </span><br><span class=\"line\">\t\t<span class=\"comment\">// In order to prevent the waiting channels from being blocked forever,  </span></span><br><span class=\"line\">\t\t<span class=\"comment\">// needs to ensure that this panic cannot be recovered.  </span></span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> <span class=\"built_in\">len</span>(c.chans) &gt; <span class=\"number\">0</span> &#123;  </span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">go</span> <span class=\"built_in\">panic</span>(e)  </span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">select</span> &#123;&#125; <span class=\"comment\">// Keep this goroutine around so that it will appear in the crash dump.  </span></span><br><span class=\"line\">\t\t\t&#125; <span class=\"keyword\">else</span> &#123;  </span><br><span class=\"line\">\t\t\t\t<span class=\"built_in\">panic</span>(e)  </span><br><span class=\"line\">\t\t\t&#125;  </span><br><span class=\"line\">\t\t&#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> c.err == errGoexit &#123;  </span><br><span class=\"line\">\t\t\t<span class=\"comment\">// Already in the process of goexit, no need to call again  </span></span><br><span class=\"line\">\t\t&#125; <span class=\"keyword\">else</span> &#123;  </span><br><span class=\"line\">\t\t\t<span class=\"comment\">// Normal return  </span></span><br><span class=\"line\">\t\t\t<span class=\"keyword\">for</span> _, ch := <span class=\"keyword\">range</span> c.chans &#123;  </span><br><span class=\"line\">\t\t\t\tch &lt;- Result&#123;c.val, c.err, c.dups &gt; <span class=\"number\">0</span>&#125;  </span><br><span class=\"line\">\t\t\t&#125;  </span><br><span class=\"line\">\t\t&#125;  </span><br><span class=\"line\">\t&#125;()  </span><br><span class=\"line\">\t  </span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">()</span></span> &#123;  </span><br><span class=\"line\">\t\t<span class=\"keyword\">defer</span> <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">()</span></span> &#123;  </span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> !normalReturn &#123;  </span><br><span class=\"line\">\t<span class=\"comment\">// Ideally, we would wait to take a stack trace until we&#x27;ve determined  </span></span><br><span class=\"line\">\t<span class=\"comment\">// whether this is a panic or a runtime.Goexit.  </span></span><br><span class=\"line\">\t<span class=\"comment\">//  </span></span><br><span class=\"line\">\t<span class=\"comment\">// Unfortunately, the only way we can distinguish the two is to see  </span></span><br><span class=\"line\">\t<span class=\"comment\">// whether the recover stopped the goroutine from terminating, and by  </span></span><br><span class=\"line\">\t<span class=\"comment\">// the time we know that, the part of the stack trace relevant to the  </span></span><br><span class=\"line\">\t<span class=\"comment\">// panic has been discarded.  </span></span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> r := <span class=\"built_in\">recover</span>(); r != <span class=\"literal\">nil</span> &#123;  </span><br><span class=\"line\">\t\t\t\tc.err = newPanicError(r)  </span><br><span class=\"line\">\t\t\t&#125;  </span><br><span class=\"line\">\t\t&#125;  </span><br><span class=\"line\">\t&#125;()  </span><br><span class=\"line\">\t  </span><br><span class=\"line\">\tc.val, c.err = fn()  </span><br><span class=\"line\">\t\tnormalReturn = <span class=\"literal\">true</span>  </span><br><span class=\"line\">\t&#125;()  </span><br><span class=\"line\">\t  </span><br><span class=\"line\">\t<span class=\"keyword\">if</span> !normalReturn &#123;  </span><br><span class=\"line\">\t\trecovered = <span class=\"literal\">true</span>  </span><br><span class=\"line\">\t&#125;  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>doCall 函数会比较长，主要是为了保证即使 fn 函数出现了 panic 或者 <code>runtime.Exit</code> 之后的处理方式。</p>\n<p>在同步的情况下，出错之后可以在 Do 中进行统一处理；而在异步的情况下，处理被交给了业务方，所以 doCall 中直接引发 panic。</p>\n<h3 id=\"WaitGroup-的使用细节\"><a href=\"#WaitGroup-的使用细节\" class=\"headerlink\" title=\"WaitGroup 的使用细节\"></a>WaitGroup 的使用细节</h3><p>整体代码中有一个有趣的细节：一般 WaitGroup 的使用方式是主线程执行 Wait 方法，多个并发的线程在完成之后执行 Done 方法，主线程等待多个并发线程执行完毕。</p>\n<p>而在 Do 和 doCall 方法中，可以第一个执行的线程会执行 Done 方法，而多个并发线程则执行 Wait 来等待第一个执行线程的执行完毕。</p>\n<h2 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h2><ul>\n<li><a href=\"https://pkg.go.dev/golang.org/x/sync/singleflight#pkg-overview\">singleflight 官方文档</a></li>\n<li><a href=\"https://juejin.cn/post/7093859835694809125#heading-0\">深入理解Golang并发工具-Singleflight</a></li>\n</ul>\n","path":"2024/06/24/singleflight简单介绍/","permalink":"https://xuh723.github.io/2024/06/24/singleflight%E7%AE%80%E5%8D%95%E4%BB%8B%E7%BB%8D/","tags":[{"name":"组件分析","_id":"clxsp136k000rigw900km7dij","slug":"组件分析","path":"tags/组件分析/","permalink":"https://xuh723.github.io/tags/%E7%BB%84%E4%BB%B6%E5%88%86%E6%9E%90/","length":2}],"categories":[],"prev":null,"next":{"title":"最短路算法小结","date":"2024-05-05T05:13:08.000Z","slug":"最短路算法小结","published":true,"updated":"2024-06-24T07:55:10.853Z","_id":"clxsp136e0008igw9akagfbct","layout":"post","photos":[],"excerpt":"","path":"2024/05/05/最短路算法小结/","permalink":"https://xuh723.github.io/2024/05/05/%E6%9C%80%E7%9F%AD%E8%B7%AF%E7%AE%97%E6%B3%95%E5%B0%8F%E7%BB%93/","__post":true},"__post":true}