{"title":"缓存模式和缓存问题介绍","date":"2024-04-05T16:27:14.000Z","toc":true,"source":"_posts/2024-04-06-缓存模式和缓存问题介绍.md","raw":"---\ntitle: 缓存模式和缓存问题介绍\ndate: 2024-04-06 00:27:14\ntags: [技术基础, 数据存储]\ntoc: true\n---\n\n缓存是用来临时存储数据的，一般来说使用缓存的目标是用来提升性能，缓解数据库的压力。\n\n有三种常见的缓存读写策略：\n\n- Cache Aside\n- Read/Write Through\n- Write Behind\n\n## 三种缓存模式的读写特点\n\n### Cache Aside（旁路缓存模式）\n\nCache Aside 模式的特点是将数据库视为数据存储的主要位置，也就是数据库存储的数据一定是最准确的，缓存仅仅是用来缓解数据库压力，提高读取性能而被使用。\n\n读请求：\n\n- 请求查询缓存，缓存中有数据，就直接返回给客户端\n- 缓存中没有数据，就会去读数据库\n- 取到数据之后，将数据放入缓存，然后返回给客户端\n\n写请求：\n\n- 数据写入数据库\n- 删除缓存中对应的数据\n\n### Read/Write Through（读写穿透模式）\n\nRead/Write Through 模式的特点是把缓存视为数据存储的主要位置，缓存基本充当了数据库的功能，而用缓存层的服务来同步数据到数据库作为备份使用。\n\n这里 Read/Write Through 和 Cache Aside 的主要区别在于在缓存层有一层封装，不需要业务对缓存、数据库进行操作，而是由这层抽象封装层来完成。\n\n读请求：\n\n- 请求查询抽象封装层，抽象层查询缓存，缓存中有数据，就直接返回给客户端\n- 缓存中没有数据，抽象层从数据库加载，写入缓存后返回\n\n写请求：\n\n- 缓存中有数据，直接更新缓存中的数据，利用抽象封装层去更新数据库\n- 缓存中没有数据，直接更新数据库\n\n### Write Behind（异步缓存写入）\n\nWrite Behind 模式的特点是只更新缓存，不直接去操作数据库。而是利用消息队列等异步的方式去更新数据库的数据。\n\n这种模式实际上是直接将缓存当做数据库来使用，数据库只是用来作为备份的，适用于数据经常变化，对于一致性要求不高的场景。\n\n读请求：\n\n- 直接查询缓存，缓存中存在直接返回给客户端\n- 缓存中不存在，查询数据库返回给客户端\n\n写请求：\n\n- 直接更新缓存\n- 异步任务，例如消息队列等更新数据库\n\n## 缓存不一致\n\n缓存不一致的最主要原因，就是在并发访问的模式下，各种操作之间的延迟和先后顺序不一致，导致可能出现数据库和缓存更新时机产生差别情况。\n\n而在 Cache Aside 模式中，已经通过设计尽可能规避了缓存不一致的情况：分别是写入时删除缓存而非更新缓存，以及先写入数据库再删除缓存。\n\n### 删除缓存而不是更新缓存\n\n- 如果同时来了写请求更新了数据库，但是后来的请求因为网络原因先更新了缓存，就会导致先来的请求后更新缓存，把缓存更新成非最新值。\n- 通过删除缓存的方式来做，就可以保证不会出现这种问题。因为只会删除缓存，不会修改缓存的值。\n- 此外，写场景频繁，或者是写入值需要计算才能得出的场景，更新缓存会浪费性能。\n\n### 写入的时候先写入数据库而不是缓存\n\n- 如果先写入缓存，在写入缓存之前删除缓存的时候，有新的读请求就会因为缓存 miss 去读取数据库，然后更新缓存，导致缓存中存在老的数据。\n- 先写入数据库，除非删除缓存操作失败，不然不会导致缓存数据不一致。\n\n### 延迟双删方案\n\n先写缓存也可以保证数据一致性，方法是延时删除缓存。\n\n- 先删除缓存\n- 写入数据库\n- 休眠一会，再次删除缓存\n\n这种方案可以缓解数据不一致的问题，只有在休眠的时候可能产生脏数据，例如休眠期间其他并发线程写入缓存数据，导致第二次删除之前数据不一致，可能性比较小。更大的问题还是频繁删除缓存，会更容易出现缓存未命中的问题。\n\n## 缓存问题\n\n说到缓存，另一个比较常见的问题关于三种缓存问题的概念。这里也简单列出这三种缓存模式的定义和解决方案。\n\n最通用的解决方案就是对请求进行限流。缓存问题的本质是数据库无法承受大批量的数据请求，如果能够限流请求的数量，到光靠数据库也可以扛住的程度，那么这些缓存问题就全部迎刃而解。\n\n### 缓存穿透\n\n数据既不在缓存之中，也不在数据库之中。\n\n表现：\n\n- 请求缓存没数据，压力到数据库\n- 数据库也没数据，没法回写缓存，下次请求还是没有，数据库依然有压力\n\n解决方法：\n\n- 查询数据库不存在时回写特殊值\n  - 查询缓存得到特殊值，知道数据不存在，就不去查数据库了\n- 布隆过滤器限流\n  - 先通过布隆过滤器判断数据是否存在\n  - 可能存在的情况下再去查询缓存和数据库\n\n### 缓存击穿\n\n数据不在缓存中，而且是热点数据。注意，如果是非热点数据，就只是普通的缓存未命中，并不算是缓存击穿。\n\n表现：\n\n- 热点数据查询，查询缓存时没数据，需要查询数据库\n- 数据库收到大量查询请求，压力突增，性能下降\n\n解决方法：\n\n- singleflight\n  - 相同的查询仅有一个查询会真正查询缓存\n  - 其他的查询等待这一个查询的结果，而不是都去查询缓存\n- 热点数据不过期\n  - 业务提前判断可能出现缓存击穿的热点数据\n  - 对于这些数据在缓存中延长过期时间，或是永久存储\n\n### 缓存雪崩\n\n大量数据同一时间过期。\n\n表现：\n\n- 大量数据过期，大量请求查询缓存时未命中，需要查询数据库\n- 数据库收到大量查询请求，压力突增，性能下降\n\n解决方法：\n\n- 随机过期时间\n  - 大批量数据插入缓存的时候，不要设置统一的过期时间\n  - 随机设置过期时间，数据会在一段时间内平稳过期，减少雪崩的概率\n\n## 参考资料\n\n- [美团二面：Redis与MySQL双写一致性如何保证？](https://mp.weixin.qq.com/s?__biz=MzkyMzU5Mzk1NQ==&mid=2247506115&idx=1&sn=431100dfa9b9ce6fa2c7d8dd125e3f78&source=41#wechat_redirect)\n- [Redis 有几种缓存读写策略](https://mp.weixin.qq.com/s/VGSlvU6a02Gls3EyF8mHFw)\n- [缓存问题：怎么解决缓存穿透、击穿和雪崩问题？](https://time.geekbang.org/column/intro/100551601?tab=catalog)\n","slug":"缓存模式和缓存问题介绍","published":true,"updated":"2024-04-28T08:17:44.315Z","_id":"clxsp136c0005igw91xvm1y80","comments":true,"layout":"post","photos":[],"html":"<p>缓存是用来临时存储数据的，一般来说使用缓存的目标是用来提升性能，缓解数据库的压力。</p>\n<p>有三种常见的缓存读写策略：</p>\n<ul>\n<li>Cache Aside</li>\n<li>Read&#x2F;Write Through</li>\n<li>Write Behind</li>\n</ul>\n<h2 id=\"三种缓存模式的读写特点\"><a href=\"#三种缓存模式的读写特点\" class=\"headerlink\" title=\"三种缓存模式的读写特点\"></a>三种缓存模式的读写特点</h2><h3 id=\"Cache-Aside（旁路缓存模式）\"><a href=\"#Cache-Aside（旁路缓存模式）\" class=\"headerlink\" title=\"Cache Aside（旁路缓存模式）\"></a>Cache Aside（旁路缓存模式）</h3><p>Cache Aside 模式的特点是将数据库视为数据存储的主要位置，也就是数据库存储的数据一定是最准确的，缓存仅仅是用来缓解数据库压力，提高读取性能而被使用。</p>\n<p>读请求：</p>\n<ul>\n<li>请求查询缓存，缓存中有数据，就直接返回给客户端</li>\n<li>缓存中没有数据，就会去读数据库</li>\n<li>取到数据之后，将数据放入缓存，然后返回给客户端</li>\n</ul>\n<p>写请求：</p>\n<ul>\n<li>数据写入数据库</li>\n<li>删除缓存中对应的数据</li>\n</ul>\n<h3 id=\"Read-Write-Through（读写穿透模式）\"><a href=\"#Read-Write-Through（读写穿透模式）\" class=\"headerlink\" title=\"Read&#x2F;Write Through（读写穿透模式）\"></a>Read&#x2F;Write Through（读写穿透模式）</h3><p>Read&#x2F;Write Through 模式的特点是把缓存视为数据存储的主要位置，缓存基本充当了数据库的功能，而用缓存层的服务来同步数据到数据库作为备份使用。</p>\n<p>这里 Read&#x2F;Write Through 和 Cache Aside 的主要区别在于在缓存层有一层封装，不需要业务对缓存、数据库进行操作，而是由这层抽象封装层来完成。</p>\n<p>读请求：</p>\n<ul>\n<li>请求查询抽象封装层，抽象层查询缓存，缓存中有数据，就直接返回给客户端</li>\n<li>缓存中没有数据，抽象层从数据库加载，写入缓存后返回</li>\n</ul>\n<p>写请求：</p>\n<ul>\n<li>缓存中有数据，直接更新缓存中的数据，利用抽象封装层去更新数据库</li>\n<li>缓存中没有数据，直接更新数据库</li>\n</ul>\n<h3 id=\"Write-Behind（异步缓存写入）\"><a href=\"#Write-Behind（异步缓存写入）\" class=\"headerlink\" title=\"Write Behind（异步缓存写入）\"></a>Write Behind（异步缓存写入）</h3><p>Write Behind 模式的特点是只更新缓存，不直接去操作数据库。而是利用消息队列等异步的方式去更新数据库的数据。</p>\n<p>这种模式实际上是直接将缓存当做数据库来使用，数据库只是用来作为备份的，适用于数据经常变化，对于一致性要求不高的场景。</p>\n<p>读请求：</p>\n<ul>\n<li>直接查询缓存，缓存中存在直接返回给客户端</li>\n<li>缓存中不存在，查询数据库返回给客户端</li>\n</ul>\n<p>写请求：</p>\n<ul>\n<li>直接更新缓存</li>\n<li>异步任务，例如消息队列等更新数据库</li>\n</ul>\n<h2 id=\"缓存不一致\"><a href=\"#缓存不一致\" class=\"headerlink\" title=\"缓存不一致\"></a>缓存不一致</h2><p>缓存不一致的最主要原因，就是在并发访问的模式下，各种操作之间的延迟和先后顺序不一致，导致可能出现数据库和缓存更新时机产生差别情况。</p>\n<p>而在 Cache Aside 模式中，已经通过设计尽可能规避了缓存不一致的情况：分别是写入时删除缓存而非更新缓存，以及先写入数据库再删除缓存。</p>\n<h3 id=\"删除缓存而不是更新缓存\"><a href=\"#删除缓存而不是更新缓存\" class=\"headerlink\" title=\"删除缓存而不是更新缓存\"></a>删除缓存而不是更新缓存</h3><ul>\n<li>如果同时来了写请求更新了数据库，但是后来的请求因为网络原因先更新了缓存，就会导致先来的请求后更新缓存，把缓存更新成非最新值。</li>\n<li>通过删除缓存的方式来做，就可以保证不会出现这种问题。因为只会删除缓存，不会修改缓存的值。</li>\n<li>此外，写场景频繁，或者是写入值需要计算才能得出的场景，更新缓存会浪费性能。</li>\n</ul>\n<h3 id=\"写入的时候先写入数据库而不是缓存\"><a href=\"#写入的时候先写入数据库而不是缓存\" class=\"headerlink\" title=\"写入的时候先写入数据库而不是缓存\"></a>写入的时候先写入数据库而不是缓存</h3><ul>\n<li>如果先写入缓存，在写入缓存之前删除缓存的时候，有新的读请求就会因为缓存 miss 去读取数据库，然后更新缓存，导致缓存中存在老的数据。</li>\n<li>先写入数据库，除非删除缓存操作失败，不然不会导致缓存数据不一致。</li>\n</ul>\n<h3 id=\"延迟双删方案\"><a href=\"#延迟双删方案\" class=\"headerlink\" title=\"延迟双删方案\"></a>延迟双删方案</h3><p>先写缓存也可以保证数据一致性，方法是延时删除缓存。</p>\n<ul>\n<li>先删除缓存</li>\n<li>写入数据库</li>\n<li>休眠一会，再次删除缓存</li>\n</ul>\n<p>这种方案可以缓解数据不一致的问题，只有在休眠的时候可能产生脏数据，例如休眠期间其他并发线程写入缓存数据，导致第二次删除之前数据不一致，可能性比较小。更大的问题还是频繁删除缓存，会更容易出现缓存未命中的问题。</p>\n<h2 id=\"缓存问题\"><a href=\"#缓存问题\" class=\"headerlink\" title=\"缓存问题\"></a>缓存问题</h2><p>说到缓存，另一个比较常见的问题关于三种缓存问题的概念。这里也简单列出这三种缓存模式的定义和解决方案。</p>\n<p>最通用的解决方案就是对请求进行限流。缓存问题的本质是数据库无法承受大批量的数据请求，如果能够限流请求的数量，到光靠数据库也可以扛住的程度，那么这些缓存问题就全部迎刃而解。</p>\n<h3 id=\"缓存穿透\"><a href=\"#缓存穿透\" class=\"headerlink\" title=\"缓存穿透\"></a>缓存穿透</h3><p>数据既不在缓存之中，也不在数据库之中。</p>\n<p>表现：</p>\n<ul>\n<li>请求缓存没数据，压力到数据库</li>\n<li>数据库也没数据，没法回写缓存，下次请求还是没有，数据库依然有压力</li>\n</ul>\n<p>解决方法：</p>\n<ul>\n<li>查询数据库不存在时回写特殊值<ul>\n<li>查询缓存得到特殊值，知道数据不存在，就不去查数据库了</li>\n</ul>\n</li>\n<li>布隆过滤器限流<ul>\n<li>先通过布隆过滤器判断数据是否存在</li>\n<li>可能存在的情况下再去查询缓存和数据库</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"缓存击穿\"><a href=\"#缓存击穿\" class=\"headerlink\" title=\"缓存击穿\"></a>缓存击穿</h3><p>数据不在缓存中，而且是热点数据。注意，如果是非热点数据，就只是普通的缓存未命中，并不算是缓存击穿。</p>\n<p>表现：</p>\n<ul>\n<li>热点数据查询，查询缓存时没数据，需要查询数据库</li>\n<li>数据库收到大量查询请求，压力突增，性能下降</li>\n</ul>\n<p>解决方法：</p>\n<ul>\n<li>singleflight<ul>\n<li>相同的查询仅有一个查询会真正查询缓存</li>\n<li>其他的查询等待这一个查询的结果，而不是都去查询缓存</li>\n</ul>\n</li>\n<li>热点数据不过期<ul>\n<li>业务提前判断可能出现缓存击穿的热点数据</li>\n<li>对于这些数据在缓存中延长过期时间，或是永久存储</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"缓存雪崩\"><a href=\"#缓存雪崩\" class=\"headerlink\" title=\"缓存雪崩\"></a>缓存雪崩</h3><p>大量数据同一时间过期。</p>\n<p>表现：</p>\n<ul>\n<li>大量数据过期，大量请求查询缓存时未命中，需要查询数据库</li>\n<li>数据库收到大量查询请求，压力突增，性能下降</li>\n</ul>\n<p>解决方法：</p>\n<ul>\n<li>随机过期时间<ul>\n<li>大批量数据插入缓存的时候，不要设置统一的过期时间</li>\n<li>随机设置过期时间，数据会在一段时间内平稳过期，减少雪崩的概率</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h2><ul>\n<li><a href=\"https://mp.weixin.qq.com/s?__biz=MzkyMzU5Mzk1NQ==&mid=2247506115&idx=1&sn=431100dfa9b9ce6fa2c7d8dd125e3f78&source=41#wechat_redirect\">美团二面：Redis与MySQL双写一致性如何保证？</a></li>\n<li><a href=\"https://mp.weixin.qq.com/s/VGSlvU6a02Gls3EyF8mHFw\">Redis 有几种缓存读写策略</a></li>\n<li><a href=\"https://time.geekbang.org/column/intro/100551601?tab=catalog\">缓存问题：怎么解决缓存穿透、击穿和雪崩问题？</a></li>\n</ul>\n","excerpt":"","more":"<p>缓存是用来临时存储数据的，一般来说使用缓存的目标是用来提升性能，缓解数据库的压力。</p>\n<p>有三种常见的缓存读写策略：</p>\n<ul>\n<li>Cache Aside</li>\n<li>Read&#x2F;Write Through</li>\n<li>Write Behind</li>\n</ul>\n<h2 id=\"三种缓存模式的读写特点\"><a href=\"#三种缓存模式的读写特点\" class=\"headerlink\" title=\"三种缓存模式的读写特点\"></a>三种缓存模式的读写特点</h2><h3 id=\"Cache-Aside（旁路缓存模式）\"><a href=\"#Cache-Aside（旁路缓存模式）\" class=\"headerlink\" title=\"Cache Aside（旁路缓存模式）\"></a>Cache Aside（旁路缓存模式）</h3><p>Cache Aside 模式的特点是将数据库视为数据存储的主要位置，也就是数据库存储的数据一定是最准确的，缓存仅仅是用来缓解数据库压力，提高读取性能而被使用。</p>\n<p>读请求：</p>\n<ul>\n<li>请求查询缓存，缓存中有数据，就直接返回给客户端</li>\n<li>缓存中没有数据，就会去读数据库</li>\n<li>取到数据之后，将数据放入缓存，然后返回给客户端</li>\n</ul>\n<p>写请求：</p>\n<ul>\n<li>数据写入数据库</li>\n<li>删除缓存中对应的数据</li>\n</ul>\n<h3 id=\"Read-Write-Through（读写穿透模式）\"><a href=\"#Read-Write-Through（读写穿透模式）\" class=\"headerlink\" title=\"Read&#x2F;Write Through（读写穿透模式）\"></a>Read&#x2F;Write Through（读写穿透模式）</h3><p>Read&#x2F;Write Through 模式的特点是把缓存视为数据存储的主要位置，缓存基本充当了数据库的功能，而用缓存层的服务来同步数据到数据库作为备份使用。</p>\n<p>这里 Read&#x2F;Write Through 和 Cache Aside 的主要区别在于在缓存层有一层封装，不需要业务对缓存、数据库进行操作，而是由这层抽象封装层来完成。</p>\n<p>读请求：</p>\n<ul>\n<li>请求查询抽象封装层，抽象层查询缓存，缓存中有数据，就直接返回给客户端</li>\n<li>缓存中没有数据，抽象层从数据库加载，写入缓存后返回</li>\n</ul>\n<p>写请求：</p>\n<ul>\n<li>缓存中有数据，直接更新缓存中的数据，利用抽象封装层去更新数据库</li>\n<li>缓存中没有数据，直接更新数据库</li>\n</ul>\n<h3 id=\"Write-Behind（异步缓存写入）\"><a href=\"#Write-Behind（异步缓存写入）\" class=\"headerlink\" title=\"Write Behind（异步缓存写入）\"></a>Write Behind（异步缓存写入）</h3><p>Write Behind 模式的特点是只更新缓存，不直接去操作数据库。而是利用消息队列等异步的方式去更新数据库的数据。</p>\n<p>这种模式实际上是直接将缓存当做数据库来使用，数据库只是用来作为备份的，适用于数据经常变化，对于一致性要求不高的场景。</p>\n<p>读请求：</p>\n<ul>\n<li>直接查询缓存，缓存中存在直接返回给客户端</li>\n<li>缓存中不存在，查询数据库返回给客户端</li>\n</ul>\n<p>写请求：</p>\n<ul>\n<li>直接更新缓存</li>\n<li>异步任务，例如消息队列等更新数据库</li>\n</ul>\n<h2 id=\"缓存不一致\"><a href=\"#缓存不一致\" class=\"headerlink\" title=\"缓存不一致\"></a>缓存不一致</h2><p>缓存不一致的最主要原因，就是在并发访问的模式下，各种操作之间的延迟和先后顺序不一致，导致可能出现数据库和缓存更新时机产生差别情况。</p>\n<p>而在 Cache Aside 模式中，已经通过设计尽可能规避了缓存不一致的情况：分别是写入时删除缓存而非更新缓存，以及先写入数据库再删除缓存。</p>\n<h3 id=\"删除缓存而不是更新缓存\"><a href=\"#删除缓存而不是更新缓存\" class=\"headerlink\" title=\"删除缓存而不是更新缓存\"></a>删除缓存而不是更新缓存</h3><ul>\n<li>如果同时来了写请求更新了数据库，但是后来的请求因为网络原因先更新了缓存，就会导致先来的请求后更新缓存，把缓存更新成非最新值。</li>\n<li>通过删除缓存的方式来做，就可以保证不会出现这种问题。因为只会删除缓存，不会修改缓存的值。</li>\n<li>此外，写场景频繁，或者是写入值需要计算才能得出的场景，更新缓存会浪费性能。</li>\n</ul>\n<h3 id=\"写入的时候先写入数据库而不是缓存\"><a href=\"#写入的时候先写入数据库而不是缓存\" class=\"headerlink\" title=\"写入的时候先写入数据库而不是缓存\"></a>写入的时候先写入数据库而不是缓存</h3><ul>\n<li>如果先写入缓存，在写入缓存之前删除缓存的时候，有新的读请求就会因为缓存 miss 去读取数据库，然后更新缓存，导致缓存中存在老的数据。</li>\n<li>先写入数据库，除非删除缓存操作失败，不然不会导致缓存数据不一致。</li>\n</ul>\n<h3 id=\"延迟双删方案\"><a href=\"#延迟双删方案\" class=\"headerlink\" title=\"延迟双删方案\"></a>延迟双删方案</h3><p>先写缓存也可以保证数据一致性，方法是延时删除缓存。</p>\n<ul>\n<li>先删除缓存</li>\n<li>写入数据库</li>\n<li>休眠一会，再次删除缓存</li>\n</ul>\n<p>这种方案可以缓解数据不一致的问题，只有在休眠的时候可能产生脏数据，例如休眠期间其他并发线程写入缓存数据，导致第二次删除之前数据不一致，可能性比较小。更大的问题还是频繁删除缓存，会更容易出现缓存未命中的问题。</p>\n<h2 id=\"缓存问题\"><a href=\"#缓存问题\" class=\"headerlink\" title=\"缓存问题\"></a>缓存问题</h2><p>说到缓存，另一个比较常见的问题关于三种缓存问题的概念。这里也简单列出这三种缓存模式的定义和解决方案。</p>\n<p>最通用的解决方案就是对请求进行限流。缓存问题的本质是数据库无法承受大批量的数据请求，如果能够限流请求的数量，到光靠数据库也可以扛住的程度，那么这些缓存问题就全部迎刃而解。</p>\n<h3 id=\"缓存穿透\"><a href=\"#缓存穿透\" class=\"headerlink\" title=\"缓存穿透\"></a>缓存穿透</h3><p>数据既不在缓存之中，也不在数据库之中。</p>\n<p>表现：</p>\n<ul>\n<li>请求缓存没数据，压力到数据库</li>\n<li>数据库也没数据，没法回写缓存，下次请求还是没有，数据库依然有压力</li>\n</ul>\n<p>解决方法：</p>\n<ul>\n<li>查询数据库不存在时回写特殊值<ul>\n<li>查询缓存得到特殊值，知道数据不存在，就不去查数据库了</li>\n</ul>\n</li>\n<li>布隆过滤器限流<ul>\n<li>先通过布隆过滤器判断数据是否存在</li>\n<li>可能存在的情况下再去查询缓存和数据库</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"缓存击穿\"><a href=\"#缓存击穿\" class=\"headerlink\" title=\"缓存击穿\"></a>缓存击穿</h3><p>数据不在缓存中，而且是热点数据。注意，如果是非热点数据，就只是普通的缓存未命中，并不算是缓存击穿。</p>\n<p>表现：</p>\n<ul>\n<li>热点数据查询，查询缓存时没数据，需要查询数据库</li>\n<li>数据库收到大量查询请求，压力突增，性能下降</li>\n</ul>\n<p>解决方法：</p>\n<ul>\n<li>singleflight<ul>\n<li>相同的查询仅有一个查询会真正查询缓存</li>\n<li>其他的查询等待这一个查询的结果，而不是都去查询缓存</li>\n</ul>\n</li>\n<li>热点数据不过期<ul>\n<li>业务提前判断可能出现缓存击穿的热点数据</li>\n<li>对于这些数据在缓存中延长过期时间，或是永久存储</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"缓存雪崩\"><a href=\"#缓存雪崩\" class=\"headerlink\" title=\"缓存雪崩\"></a>缓存雪崩</h3><p>大量数据同一时间过期。</p>\n<p>表现：</p>\n<ul>\n<li>大量数据过期，大量请求查询缓存时未命中，需要查询数据库</li>\n<li>数据库收到大量查询请求，压力突增，性能下降</li>\n</ul>\n<p>解决方法：</p>\n<ul>\n<li>随机过期时间<ul>\n<li>大批量数据插入缓存的时候，不要设置统一的过期时间</li>\n<li>随机设置过期时间，数据会在一段时间内平稳过期，减少雪崩的概率</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h2><ul>\n<li><a href=\"https://mp.weixin.qq.com/s?__biz=MzkyMzU5Mzk1NQ==&mid=2247506115&idx=1&sn=431100dfa9b9ce6fa2c7d8dd125e3f78&source=41#wechat_redirect\">美团二面：Redis与MySQL双写一致性如何保证？</a></li>\n<li><a href=\"https://mp.weixin.qq.com/s/VGSlvU6a02Gls3EyF8mHFw\">Redis 有几种缓存读写策略</a></li>\n<li><a href=\"https://time.geekbang.org/column/intro/100551601?tab=catalog\">缓存问题：怎么解决缓存穿透、击穿和雪崩问题？</a></li>\n</ul>\n","path":"2024/04/06/缓存模式和缓存问题介绍/","permalink":"https://xuh723.github.io/2024/04/06/%E7%BC%93%E5%AD%98%E6%A8%A1%E5%BC%8F%E5%92%8C%E7%BC%93%E5%AD%98%E9%97%AE%E9%A2%98%E4%BB%8B%E7%BB%8D/","tags":[{"name":"技术基础","_id":"clxsp136d0006igw96pg970pq","slug":"技术基础","path":"tags/技术基础/","permalink":"https://xuh723.github.io/tags/%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80/","length":5},{"name":"数据存储","_id":"clxsp136i000figw92ve75x23","slug":"数据存储","path":"tags/数据存储/","permalink":"https://xuh723.github.io/tags/%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8/","length":3}],"categories":[],"prev":{"title":"groupcache简单介绍","date":"2024-04-28T08:15:32.000Z","slug":"groupcache简单介绍","published":true,"updated":"2024-04-28T08:20:18.535Z","_id":"clxsp136e0009igw98kcv0930","layout":"post","photos":[],"excerpt":"","path":"2024/04/28/groupcache简单介绍/","permalink":"https://xuh723.github.io/2024/04/28/groupcache%E7%AE%80%E5%8D%95%E4%BB%8B%E7%BB%8D/","__post":true},"next":{"title":"Raft算法基础介绍","date":"2024-04-03T13:33:09.000Z","slug":"Raft算法基础介绍","published":true,"updated":"2024-04-28T08:14:46.218Z","_id":"clxsp136b0004igw9a1skfn3f","layout":"post","photos":[],"excerpt":"","path":"2024/04/03/Raft算法基础介绍/","permalink":"https://xuh723.github.io/2024/04/03/Raft%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E4%BB%8B%E7%BB%8D/","__post":true},"__post":true}