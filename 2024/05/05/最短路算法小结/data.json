{"title":"最短路算法小结","date":"2024-05-05T05:13:08.000Z","toc":true,"source":"_posts/2024-05-05-最短路算法小结.md","raw":"---\ntitle: 最短路算法小结\ndate: 2024-05-05 13:13:08\ntags: [技术基础, 算法]\ntoc: true\n---\n\n最短路算法，简单来说就是求出给定的图中，两点或者多点之间距离最短的路径的算法。一般来说，这种算法不会特意拿出来出题，但是如果拿出来出题了，而我们没有掌握相关算法的话就会一筹莫展。\n\n本文将简单介绍几种常用的最短路算法，和它们的 C++实现与例题。\n\n## Dijkstra 算法\n\nDijkstra 算法是用于求解**非负权图**上单源最短路径的算法。核心要点是图上不能有权重为负数的边，否则就不适用 Dijkstra 算法。\n\nDijkstra 算法的过程很简单：\n\n1. 将所有节点划分为两个集合，已确定最短路的点集 S，和未确定最短路的点集 T\n2. 从 T 集合中选择一个最短路长度最小的节点，移动到 S 集合\n3. 对刚才选择的节点的所有出边进行松弛（relax）操作\n4. 重复 2-3 步，直到 T 集合为空\n\n需要提一下的是松弛操作，对边 `(u, v)` 的松弛操作，指的是用节点 u 的最短路+边 `(u, v)` 的边权重，和节点 v 的最短路进行比较，看看是否需要更新最短路，公式如下：\n\n```math\ndis(v)=min(dis(v), dis(u)+w(u,v))\n```\n\n简单的 Dijkstra 的 C++参考代码如下：\n\n```C++\nconst int mxn=1005;\nint g[mxn][mxn],dis[mxn],vis[mxn];\n \nvoid dijkstra(int s)  //s为起点 \n{\n    //如果需要路线，就再开一个数组记录 \n    memset(dis,0x3f,sizeof(dis));\n    memset(vis,0,sizeof(vis));\n    vis[s]=1;dis[s]=0;\n    for (int i=0;i<n;i++)  //n是点数(mxn)，这里需要循环次数为n次 \n    {\n        for (int j=0;j<n;j++) //这里需要注意点的编号\n        {\n            if (g[s][j]!=0) dis[j]=min(dis[j],dis[s]+g[s][j]);\n        }\n        for (int j=0;j<n;j++) {\n            if (!vis[j]&&(vis[s]||dis[s]>dis[j])) s=j;  //找那一行不属于集合已经找到的且最小的作为下一个起点\n        }        \n        vis[s]=1;\n    }\n}  //这样就求出了所有点到s的最短路\n```\n\n### 堆优化\n\nDijkstra 算法的优化，主要是针对第 2 步，从集合 T 中选择一个最短路长度最小的节点。\n\n常规的暴力算法，整体的算法时间复杂度是 `O(n^2)`，而比较常用的优化方式就是利用堆来进行优化。每次成功松弛一条边，就将这条边放入堆中。下次从集合 T 取出最短路长度最小的节点时，就可以直接取出堆顶端的节点来代替。\n\n优化后的算法时间复杂度为 `O(mlogn)`。注意，如果边大于点的话，堆优化后可能会更慢。\n\n```C++\nconst int mxn=1005;\nint g[mxn][mxn],dis[mxn],vis[mxn];\npriority_queue<pair<int, int>, vector<pair<int, int> >, greater<pair<int, int> > > q;\n \nvoid dijkstra(int s)  //s为起点\n{\n    //如果需要路线，就再开一个数组记录\n    memset(dis,0x3f,sizeof(dis));\n    dis[s]=0;\n    q.emplace(dis[s], s);\n    while(!q.empty())\n    {\n        auto [d, s] = q.top();\n        q.pop();\n        if (d>dis[s]) continue;\n        for (int j=0;j<n;j++) //这里需要注意点的编号\n        {\n            if (g[s][j]!=0) {\n                if (dis[j]<dis[s]+g[s][j]) {\n                    dis[j]=dis[s]+g[s][j];\n                    q.emplace(dis[j],j);\n                }\n            }\n        }\n    }\n}  //这样就求出了所有点到s的最短路\n```\n\n## Bellman-Ford 算法\n\nBellman–Ford 算法是一种基于松弛操作的最短路算法，可以求出**有负权的图**的最短路，并可以对最短路不存在的情况进行判断。\n\n每次循环的时候，算法都会尝试对所有的边进行一次松弛。在最短路存在的情况下，每次松弛都会确定一条最短路的边，所以最多只需要 `n-1` 次松弛就可以得到最短路，时间复杂度为 `O(nm)`。\n\n从 Bellman–Ford 的实现方式也可以看出，如果图中存在负环，那么松弛操作就会一直进行下去。因此 Bellman–Ford 算法也可以用来判断图中是否存在负环：如果在进行了 n-1 轮松弛操作之后，还存在可以松弛的边，就说明图中存在负环。\n\n```C++\n// 经典算法\nvoid bf() {\n    // 起始先将所有的点标记为「距离为正无穷」\n    Arrays.fill(dist, INF);\n    // 只有起点最短距离为 0\n    dist[k] = 0;\n    // 迭代 n 次\n    for (int p = 1; p <= n; p++) {\n        int[] prev = dist.clone();\n        // 每次都使用上一次迭代的结果，执行松弛操作\n        for (Edge e : es) {\n            int a = e.a, b = e.b, c = e.c;\n            dist[b] = Math.min(dist[b], prev[a] + c);\n        }\n    }\n}\n```\n\n### SPFA 算法优化\n\nSPFA，Shortest Path Faster Algorithm，是对 Bellman-Ford 算法的一种优化。\n\n在 Bellman–Ford 算法中，只有上一次被松弛的边连接的节点，才可能引起下一次的松弛操作。我们可以用队列来维护可能会引起松弛操作的节点，就可以只访问必要的边。\n\nSPFA 也可以用来判断是否存在负环，当最短路经过了 n 条边时，就可以知道已经到达了一个负环，因为一般的最短路的长度最多是 n-1。\n\n```C++\nconst int mxn=1005;\nint q[mxn],head,tail,cnt;  //循环队列\nint first[mxn],nxt[mxn<<1],vv[mxn<<1],cost[mxn<<1];  //数组模拟邻接表\nint dis[mxn],iin[mxn];  //判断是否在队列内 \n\nvoid spfa(int s,int t)  //s起点，t终点（其实不传也没什么……） \n{\n    memset(dis,0x3f,sizeof(dis));\n    memset(iin,0,sizeof(iin));\n    dis[s]=0;  //这步不要忘了……虽然即使忘了测试时也会检查出来…… \n    q[tail]=s;iin[s]=1;cnt++;tail=(tail+1)%mxn;  //入队 \n    while (cnt!=0)\n    {\n        int u=q[head];\n        iin[u]=0;cnt--;head=(head+1)%mxn;  //出队\n        for (int i=first[u];i!=-1;i=nxt[i])\n        {\n            int v=vv[i];\n            if (dis[v]>dis[u]+cost[i])  //可以松弛 \n            {\n                dis[v]=dis[u]+cost[i];\n                if (iin[v]==0)\n                {\n                    iin[v]=1;\n                    q[tail]=v;\n                    tail=(tail+1)%mxn;\n                    cnt++;\n                }\n            }\n        }\n    }\n}  //dis[t]即为到t的最短路（具体看点的编号）\n```\n\n## Floyd 算法\n\n用来求任意两个节点之间最短路的**多源最短路算法**，时间复杂度比较高为 `O(n^3)`。在需要求多源最短路的情况下可以使用。\n\n```C++\nconst int mxn=1005;\nint g[mxn][mxn];\n\nvoid Floyd(int n)  //n为点的个数 \n{\n    memset(g,0x3f,sizeof(g));\n    for (int i=0;i<n;i++)\n        g[i][i]=0;\n    for (int k=0;k<n;k++)  //注意k要在最外面 \n        for (int i=0;i<n;i++)\n            for (int j=0;j<n;j++)\n                if (g[i][j]>g[i][k]+g[k][j]) g[i][j]=g[i][k]+g[k][j];\n}  //g[i][j]即为i到j的最短路\n```\n\n## 小结\n\nDIjkstra 算法是最常用的求最短路的算法，可以求出某一个点到其他点的最短路。需要注意 Dijkstra 算法的两个适用范围：\n\n1. Dijkstra 求出的是从某一个点出发的单源最短路径\n2. Dijkstra 算法要求图中不存在权值为负数的边\n\n如果图中存在权值为负数的边，那就需要用 Bellman-Ford 算法以及它的优化 SPFA 算法；如果需要求所有点的多源最短路径，那就需要用 Floyd 算法进行求解。\n\n## 参考资料\n\n- [最短路-OI Wiki](https://oi-wiki.org/graph/shortest-path/#dijkstra-%E7%AE%97%E6%B3%95)\n","slug":"最短路算法小结","published":true,"updated":"2024-06-24T07:55:10.853Z","_id":"clxsp136e0008igw9akagfbct","comments":true,"layout":"post","photos":[],"html":"<p>最短路算法，简单来说就是求出给定的图中，两点或者多点之间距离最短的路径的算法。一般来说，这种算法不会特意拿出来出题，但是如果拿出来出题了，而我们没有掌握相关算法的话就会一筹莫展。</p>\n<p>本文将简单介绍几种常用的最短路算法，和它们的 C++实现与例题。</p>\n<h2 id=\"Dijkstra-算法\"><a href=\"#Dijkstra-算法\" class=\"headerlink\" title=\"Dijkstra 算法\"></a>Dijkstra 算法</h2><p>Dijkstra 算法是用于求解<strong>非负权图</strong>上单源最短路径的算法。核心要点是图上不能有权重为负数的边，否则就不适用 Dijkstra 算法。</p>\n<p>Dijkstra 算法的过程很简单：</p>\n<ol>\n<li>将所有节点划分为两个集合，已确定最短路的点集 S，和未确定最短路的点集 T</li>\n<li>从 T 集合中选择一个最短路长度最小的节点，移动到 S 集合</li>\n<li>对刚才选择的节点的所有出边进行松弛（relax）操作</li>\n<li>重复 2-3 步，直到 T 集合为空</li>\n</ol>\n<p>需要提一下的是松弛操作，对边 <code>(u, v)</code> 的松弛操作，指的是用节点 u 的最短路+边 <code>(u, v)</code> 的边权重，和节点 v 的最短路进行比较，看看是否需要更新最短路，公式如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">dis(v)=min(dis(v), dis(u)+w(u,v))</span><br></pre></td></tr></table></figure>\n\n<p>简单的 Dijkstra 的 C++参考代码如下：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">const</span> <span class=\"type\">int</span> mxn=<span class=\"number\">1005</span>;</span><br><span class=\"line\"><span class=\"type\">int</span> g[mxn][mxn],dis[mxn],vis[mxn];</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">dijkstra</span><span class=\"params\">(<span class=\"type\">int</span> s)</span>  <span class=\"comment\">//s为起点 </span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//如果需要路线，就再开一个数组记录 </span></span><br><span class=\"line\">    <span class=\"built_in\">memset</span>(dis,<span class=\"number\">0x3f</span>,<span class=\"built_in\">sizeof</span>(dis));</span><br><span class=\"line\">    <span class=\"built_in\">memset</span>(vis,<span class=\"number\">0</span>,<span class=\"built_in\">sizeof</span>(vis));</span><br><span class=\"line\">    vis[s]=<span class=\"number\">1</span>;dis[s]=<span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">0</span>;i&lt;n;i++)  <span class=\"comment\">//n是点数(mxn)，这里需要循环次数为n次 </span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> j=<span class=\"number\">0</span>;j&lt;n;j++) <span class=\"comment\">//这里需要注意点的编号</span></span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (g[s][j]!=<span class=\"number\">0</span>) dis[j]=<span class=\"built_in\">min</span>(dis[j],dis[s]+g[s][j]);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> j=<span class=\"number\">0</span>;j&lt;n;j++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (!vis[j]&amp;&amp;(vis[s]||dis[s]&gt;dis[j])) s=j;  <span class=\"comment\">//找那一行不属于集合已经找到的且最小的作为下一个起点</span></span><br><span class=\"line\">        &#125;        </span><br><span class=\"line\">        vis[s]=<span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;  <span class=\"comment\">//这样就求出了所有点到s的最短路</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"堆优化\"><a href=\"#堆优化\" class=\"headerlink\" title=\"堆优化\"></a>堆优化</h3><p>Dijkstra 算法的优化，主要是针对第 2 步，从集合 T 中选择一个最短路长度最小的节点。</p>\n<p>常规的暴力算法，整体的算法时间复杂度是 <code>O(n^2)</code>，而比较常用的优化方式就是利用堆来进行优化。每次成功松弛一条边，就将这条边放入堆中。下次从集合 T 取出最短路长度最小的节点时，就可以直接取出堆顶端的节点来代替。</p>\n<p>优化后的算法时间复杂度为 <code>O(mlogn)</code>。注意，如果边大于点的话，堆优化后可能会更慢。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">const</span> <span class=\"type\">int</span> mxn=<span class=\"number\">1005</span>;</span><br><span class=\"line\"><span class=\"type\">int</span> g[mxn][mxn],dis[mxn],vis[mxn];</span><br><span class=\"line\">priority_queue&lt;pair&lt;<span class=\"type\">int</span>, <span class=\"type\">int</span>&gt;, vector&lt;pair&lt;<span class=\"type\">int</span>, <span class=\"type\">int</span>&gt; &gt;, greater&lt;pair&lt;<span class=\"type\">int</span>, <span class=\"type\">int</span>&gt; &gt; &gt; q;</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">dijkstra</span><span class=\"params\">(<span class=\"type\">int</span> s)</span>  <span class=\"comment\">//s为起点</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//如果需要路线，就再开一个数组记录</span></span><br><span class=\"line\">    <span class=\"built_in\">memset</span>(dis,<span class=\"number\">0x3f</span>,<span class=\"built_in\">sizeof</span>(dis));</span><br><span class=\"line\">    dis[s]=<span class=\"number\">0</span>;</span><br><span class=\"line\">    q.<span class=\"built_in\">emplace</span>(dis[s], s);</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(!q.<span class=\"built_in\">empty</span>())</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">auto</span> [d, s] = q.<span class=\"built_in\">top</span>();</span><br><span class=\"line\">        q.<span class=\"built_in\">pop</span>();</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (d&gt;dis[s]) <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> j=<span class=\"number\">0</span>;j&lt;n;j++) <span class=\"comment\">//这里需要注意点的编号</span></span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (g[s][j]!=<span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (dis[j]&lt;dis[s]+g[s][j]) &#123;</span><br><span class=\"line\">                    dis[j]=dis[s]+g[s][j];</span><br><span class=\"line\">                    q.<span class=\"built_in\">emplace</span>(dis[j],j);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;  <span class=\"comment\">//这样就求出了所有点到s的最短路</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"Bellman-Ford-算法\"><a href=\"#Bellman-Ford-算法\" class=\"headerlink\" title=\"Bellman-Ford 算法\"></a>Bellman-Ford 算法</h2><p>Bellman–Ford 算法是一种基于松弛操作的最短路算法，可以求出<strong>有负权的图</strong>的最短路，并可以对最短路不存在的情况进行判断。</p>\n<p>每次循环的时候，算法都会尝试对所有的边进行一次松弛。在最短路存在的情况下，每次松弛都会确定一条最短路的边，所以最多只需要 <code>n-1</code> 次松弛就可以得到最短路，时间复杂度为 <code>O(nm)</code>。</p>\n<p>从 Bellman–Ford 的实现方式也可以看出，如果图中存在负环，那么松弛操作就会一直进行下去。因此 Bellman–Ford 算法也可以用来判断图中是否存在负环：如果在进行了 n-1 轮松弛操作之后，还存在可以松弛的边，就说明图中存在负环。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 经典算法</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">bf</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 起始先将所有的点标记为「距离为正无穷」</span></span><br><span class=\"line\">    Arrays.<span class=\"built_in\">fill</span>(dist, INF);</span><br><span class=\"line\">    <span class=\"comment\">// 只有起点最短距离为 0</span></span><br><span class=\"line\">    dist[k] = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"comment\">// 迭代 n 次</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> p = <span class=\"number\">1</span>; p &lt;= n; p++) &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span>[] prev = dist.<span class=\"built_in\">clone</span>();</span><br><span class=\"line\">        <span class=\"comment\">// 每次都使用上一次迭代的结果，执行松弛操作</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (Edge e : es) &#123;</span><br><span class=\"line\">            <span class=\"type\">int</span> a = e.a, b = e.b, c = e.c;</span><br><span class=\"line\">            dist[b] = Math.<span class=\"built_in\">min</span>(dist[b], prev[a] + c);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"SPFA-算法优化\"><a href=\"#SPFA-算法优化\" class=\"headerlink\" title=\"SPFA 算法优化\"></a>SPFA 算法优化</h3><p>SPFA，Shortest Path Faster Algorithm，是对 Bellman-Ford 算法的一种优化。</p>\n<p>在 Bellman–Ford 算法中，只有上一次被松弛的边连接的节点，才可能引起下一次的松弛操作。我们可以用队列来维护可能会引起松弛操作的节点，就可以只访问必要的边。</p>\n<p>SPFA 也可以用来判断是否存在负环，当最短路经过了 n 条边时，就可以知道已经到达了一个负环，因为一般的最短路的长度最多是 n-1。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">const</span> <span class=\"type\">int</span> mxn=<span class=\"number\">1005</span>;</span><br><span class=\"line\"><span class=\"type\">int</span> q[mxn],head,tail,cnt;  <span class=\"comment\">//循环队列</span></span><br><span class=\"line\"><span class=\"type\">int</span> first[mxn],nxt[mxn&lt;&lt;<span class=\"number\">1</span>],vv[mxn&lt;&lt;<span class=\"number\">1</span>],cost[mxn&lt;&lt;<span class=\"number\">1</span>];  <span class=\"comment\">//数组模拟邻接表</span></span><br><span class=\"line\"><span class=\"type\">int</span> dis[mxn],iin[mxn];  <span class=\"comment\">//判断是否在队列内 </span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">spfa</span><span class=\"params\">(<span class=\"type\">int</span> s,<span class=\"type\">int</span> t)</span>  <span class=\"comment\">//s起点，t终点（其实不传也没什么……） </span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">memset</span>(dis,<span class=\"number\">0x3f</span>,<span class=\"built_in\">sizeof</span>(dis));</span><br><span class=\"line\">    <span class=\"built_in\">memset</span>(iin,<span class=\"number\">0</span>,<span class=\"built_in\">sizeof</span>(iin));</span><br><span class=\"line\">    dis[s]=<span class=\"number\">0</span>;  <span class=\"comment\">//这步不要忘了……虽然即使忘了测试时也会检查出来…… </span></span><br><span class=\"line\">    q[tail]=s;iin[s]=<span class=\"number\">1</span>;cnt++;tail=(tail+<span class=\"number\">1</span>)%mxn;  <span class=\"comment\">//入队 </span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> (cnt!=<span class=\"number\">0</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> u=q[head];</span><br><span class=\"line\">        iin[u]=<span class=\"number\">0</span>;cnt--;head=(head+<span class=\"number\">1</span>)%mxn;  <span class=\"comment\">//出队</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=first[u];i!=<span class=\"number\">-1</span>;i=nxt[i])</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"type\">int</span> v=vv[i];</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (dis[v]&gt;dis[u]+cost[i])  <span class=\"comment\">//可以松弛 </span></span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                dis[v]=dis[u]+cost[i];</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (iin[v]==<span class=\"number\">0</span>)</span><br><span class=\"line\">                &#123;</span><br><span class=\"line\">                    iin[v]=<span class=\"number\">1</span>;</span><br><span class=\"line\">                    q[tail]=v;</span><br><span class=\"line\">                    tail=(tail+<span class=\"number\">1</span>)%mxn;</span><br><span class=\"line\">                    cnt++;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;  <span class=\"comment\">//dis[t]即为到t的最短路（具体看点的编号）</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"Floyd-算法\"><a href=\"#Floyd-算法\" class=\"headerlink\" title=\"Floyd 算法\"></a>Floyd 算法</h2><p>用来求任意两个节点之间最短路的<strong>多源最短路算法</strong>，时间复杂度比较高为 <code>O(n^3)</code>。在需要求多源最短路的情况下可以使用。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">const</span> <span class=\"type\">int</span> mxn=<span class=\"number\">1005</span>;</span><br><span class=\"line\"><span class=\"type\">int</span> g[mxn][mxn];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">Floyd</span><span class=\"params\">(<span class=\"type\">int</span> n)</span>  <span class=\"comment\">//n为点的个数 </span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">memset</span>(g,<span class=\"number\">0x3f</span>,<span class=\"built_in\">sizeof</span>(g));</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">0</span>;i&lt;n;i++)</span><br><span class=\"line\">        g[i][i]=<span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> k=<span class=\"number\">0</span>;k&lt;n;k++)  <span class=\"comment\">//注意k要在最外面 </span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">0</span>;i&lt;n;i++)</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"type\">int</span> j=<span class=\"number\">0</span>;j&lt;n;j++)</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (g[i][j]&gt;g[i][k]+g[k][j]) g[i][j]=g[i][k]+g[k][j];</span><br><span class=\"line\">&#125;  <span class=\"comment\">//g[i][j]即为i到j的最短路</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"小结\"><a href=\"#小结\" class=\"headerlink\" title=\"小结\"></a>小结</h2><p>DIjkstra 算法是最常用的求最短路的算法，可以求出某一个点到其他点的最短路。需要注意 Dijkstra 算法的两个适用范围：</p>\n<ol>\n<li>Dijkstra 求出的是从某一个点出发的单源最短路径</li>\n<li>Dijkstra 算法要求图中不存在权值为负数的边</li>\n</ol>\n<p>如果图中存在权值为负数的边，那就需要用 Bellman-Ford 算法以及它的优化 SPFA 算法；如果需要求所有点的多源最短路径，那就需要用 Floyd 算法进行求解。</p>\n<h2 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h2><ul>\n<li><a href=\"https://oi-wiki.org/graph/shortest-path/#dijkstra-%E7%AE%97%E6%B3%95\">最短路-OI Wiki</a></li>\n</ul>\n","excerpt":"","more":"<p>最短路算法，简单来说就是求出给定的图中，两点或者多点之间距离最短的路径的算法。一般来说，这种算法不会特意拿出来出题，但是如果拿出来出题了，而我们没有掌握相关算法的话就会一筹莫展。</p>\n<p>本文将简单介绍几种常用的最短路算法，和它们的 C++实现与例题。</p>\n<h2 id=\"Dijkstra-算法\"><a href=\"#Dijkstra-算法\" class=\"headerlink\" title=\"Dijkstra 算法\"></a>Dijkstra 算法</h2><p>Dijkstra 算法是用于求解<strong>非负权图</strong>上单源最短路径的算法。核心要点是图上不能有权重为负数的边，否则就不适用 Dijkstra 算法。</p>\n<p>Dijkstra 算法的过程很简单：</p>\n<ol>\n<li>将所有节点划分为两个集合，已确定最短路的点集 S，和未确定最短路的点集 T</li>\n<li>从 T 集合中选择一个最短路长度最小的节点，移动到 S 集合</li>\n<li>对刚才选择的节点的所有出边进行松弛（relax）操作</li>\n<li>重复 2-3 步，直到 T 集合为空</li>\n</ol>\n<p>需要提一下的是松弛操作，对边 <code>(u, v)</code> 的松弛操作，指的是用节点 u 的最短路+边 <code>(u, v)</code> 的边权重，和节点 v 的最短路进行比较，看看是否需要更新最短路，公式如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">dis(v)=min(dis(v), dis(u)+w(u,v))</span><br></pre></td></tr></table></figure>\n\n<p>简单的 Dijkstra 的 C++参考代码如下：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">const</span> <span class=\"type\">int</span> mxn=<span class=\"number\">1005</span>;</span><br><span class=\"line\"><span class=\"type\">int</span> g[mxn][mxn],dis[mxn],vis[mxn];</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">dijkstra</span><span class=\"params\">(<span class=\"type\">int</span> s)</span>  <span class=\"comment\">//s为起点 </span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//如果需要路线，就再开一个数组记录 </span></span><br><span class=\"line\">    <span class=\"built_in\">memset</span>(dis,<span class=\"number\">0x3f</span>,<span class=\"built_in\">sizeof</span>(dis));</span><br><span class=\"line\">    <span class=\"built_in\">memset</span>(vis,<span class=\"number\">0</span>,<span class=\"built_in\">sizeof</span>(vis));</span><br><span class=\"line\">    vis[s]=<span class=\"number\">1</span>;dis[s]=<span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">0</span>;i&lt;n;i++)  <span class=\"comment\">//n是点数(mxn)，这里需要循环次数为n次 </span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> j=<span class=\"number\">0</span>;j&lt;n;j++) <span class=\"comment\">//这里需要注意点的编号</span></span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (g[s][j]!=<span class=\"number\">0</span>) dis[j]=<span class=\"built_in\">min</span>(dis[j],dis[s]+g[s][j]);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> j=<span class=\"number\">0</span>;j&lt;n;j++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (!vis[j]&amp;&amp;(vis[s]||dis[s]&gt;dis[j])) s=j;  <span class=\"comment\">//找那一行不属于集合已经找到的且最小的作为下一个起点</span></span><br><span class=\"line\">        &#125;        </span><br><span class=\"line\">        vis[s]=<span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;  <span class=\"comment\">//这样就求出了所有点到s的最短路</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"堆优化\"><a href=\"#堆优化\" class=\"headerlink\" title=\"堆优化\"></a>堆优化</h3><p>Dijkstra 算法的优化，主要是针对第 2 步，从集合 T 中选择一个最短路长度最小的节点。</p>\n<p>常规的暴力算法，整体的算法时间复杂度是 <code>O(n^2)</code>，而比较常用的优化方式就是利用堆来进行优化。每次成功松弛一条边，就将这条边放入堆中。下次从集合 T 取出最短路长度最小的节点时，就可以直接取出堆顶端的节点来代替。</p>\n<p>优化后的算法时间复杂度为 <code>O(mlogn)</code>。注意，如果边大于点的话，堆优化后可能会更慢。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">const</span> <span class=\"type\">int</span> mxn=<span class=\"number\">1005</span>;</span><br><span class=\"line\"><span class=\"type\">int</span> g[mxn][mxn],dis[mxn],vis[mxn];</span><br><span class=\"line\">priority_queue&lt;pair&lt;<span class=\"type\">int</span>, <span class=\"type\">int</span>&gt;, vector&lt;pair&lt;<span class=\"type\">int</span>, <span class=\"type\">int</span>&gt; &gt;, greater&lt;pair&lt;<span class=\"type\">int</span>, <span class=\"type\">int</span>&gt; &gt; &gt; q;</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">dijkstra</span><span class=\"params\">(<span class=\"type\">int</span> s)</span>  <span class=\"comment\">//s为起点</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//如果需要路线，就再开一个数组记录</span></span><br><span class=\"line\">    <span class=\"built_in\">memset</span>(dis,<span class=\"number\">0x3f</span>,<span class=\"built_in\">sizeof</span>(dis));</span><br><span class=\"line\">    dis[s]=<span class=\"number\">0</span>;</span><br><span class=\"line\">    q.<span class=\"built_in\">emplace</span>(dis[s], s);</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(!q.<span class=\"built_in\">empty</span>())</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">auto</span> [d, s] = q.<span class=\"built_in\">top</span>();</span><br><span class=\"line\">        q.<span class=\"built_in\">pop</span>();</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (d&gt;dis[s]) <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> j=<span class=\"number\">0</span>;j&lt;n;j++) <span class=\"comment\">//这里需要注意点的编号</span></span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (g[s][j]!=<span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (dis[j]&lt;dis[s]+g[s][j]) &#123;</span><br><span class=\"line\">                    dis[j]=dis[s]+g[s][j];</span><br><span class=\"line\">                    q.<span class=\"built_in\">emplace</span>(dis[j],j);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;  <span class=\"comment\">//这样就求出了所有点到s的最短路</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"Bellman-Ford-算法\"><a href=\"#Bellman-Ford-算法\" class=\"headerlink\" title=\"Bellman-Ford 算法\"></a>Bellman-Ford 算法</h2><p>Bellman–Ford 算法是一种基于松弛操作的最短路算法，可以求出<strong>有负权的图</strong>的最短路，并可以对最短路不存在的情况进行判断。</p>\n<p>每次循环的时候，算法都会尝试对所有的边进行一次松弛。在最短路存在的情况下，每次松弛都会确定一条最短路的边，所以最多只需要 <code>n-1</code> 次松弛就可以得到最短路，时间复杂度为 <code>O(nm)</code>。</p>\n<p>从 Bellman–Ford 的实现方式也可以看出，如果图中存在负环，那么松弛操作就会一直进行下去。因此 Bellman–Ford 算法也可以用来判断图中是否存在负环：如果在进行了 n-1 轮松弛操作之后，还存在可以松弛的边，就说明图中存在负环。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 经典算法</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">bf</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 起始先将所有的点标记为「距离为正无穷」</span></span><br><span class=\"line\">    Arrays.<span class=\"built_in\">fill</span>(dist, INF);</span><br><span class=\"line\">    <span class=\"comment\">// 只有起点最短距离为 0</span></span><br><span class=\"line\">    dist[k] = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"comment\">// 迭代 n 次</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> p = <span class=\"number\">1</span>; p &lt;= n; p++) &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span>[] prev = dist.<span class=\"built_in\">clone</span>();</span><br><span class=\"line\">        <span class=\"comment\">// 每次都使用上一次迭代的结果，执行松弛操作</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (Edge e : es) &#123;</span><br><span class=\"line\">            <span class=\"type\">int</span> a = e.a, b = e.b, c = e.c;</span><br><span class=\"line\">            dist[b] = Math.<span class=\"built_in\">min</span>(dist[b], prev[a] + c);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"SPFA-算法优化\"><a href=\"#SPFA-算法优化\" class=\"headerlink\" title=\"SPFA 算法优化\"></a>SPFA 算法优化</h3><p>SPFA，Shortest Path Faster Algorithm，是对 Bellman-Ford 算法的一种优化。</p>\n<p>在 Bellman–Ford 算法中，只有上一次被松弛的边连接的节点，才可能引起下一次的松弛操作。我们可以用队列来维护可能会引起松弛操作的节点，就可以只访问必要的边。</p>\n<p>SPFA 也可以用来判断是否存在负环，当最短路经过了 n 条边时，就可以知道已经到达了一个负环，因为一般的最短路的长度最多是 n-1。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">const</span> <span class=\"type\">int</span> mxn=<span class=\"number\">1005</span>;</span><br><span class=\"line\"><span class=\"type\">int</span> q[mxn],head,tail,cnt;  <span class=\"comment\">//循环队列</span></span><br><span class=\"line\"><span class=\"type\">int</span> first[mxn],nxt[mxn&lt;&lt;<span class=\"number\">1</span>],vv[mxn&lt;&lt;<span class=\"number\">1</span>],cost[mxn&lt;&lt;<span class=\"number\">1</span>];  <span class=\"comment\">//数组模拟邻接表</span></span><br><span class=\"line\"><span class=\"type\">int</span> dis[mxn],iin[mxn];  <span class=\"comment\">//判断是否在队列内 </span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">spfa</span><span class=\"params\">(<span class=\"type\">int</span> s,<span class=\"type\">int</span> t)</span>  <span class=\"comment\">//s起点，t终点（其实不传也没什么……） </span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">memset</span>(dis,<span class=\"number\">0x3f</span>,<span class=\"built_in\">sizeof</span>(dis));</span><br><span class=\"line\">    <span class=\"built_in\">memset</span>(iin,<span class=\"number\">0</span>,<span class=\"built_in\">sizeof</span>(iin));</span><br><span class=\"line\">    dis[s]=<span class=\"number\">0</span>;  <span class=\"comment\">//这步不要忘了……虽然即使忘了测试时也会检查出来…… </span></span><br><span class=\"line\">    q[tail]=s;iin[s]=<span class=\"number\">1</span>;cnt++;tail=(tail+<span class=\"number\">1</span>)%mxn;  <span class=\"comment\">//入队 </span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> (cnt!=<span class=\"number\">0</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> u=q[head];</span><br><span class=\"line\">        iin[u]=<span class=\"number\">0</span>;cnt--;head=(head+<span class=\"number\">1</span>)%mxn;  <span class=\"comment\">//出队</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=first[u];i!=<span class=\"number\">-1</span>;i=nxt[i])</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"type\">int</span> v=vv[i];</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (dis[v]&gt;dis[u]+cost[i])  <span class=\"comment\">//可以松弛 </span></span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                dis[v]=dis[u]+cost[i];</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (iin[v]==<span class=\"number\">0</span>)</span><br><span class=\"line\">                &#123;</span><br><span class=\"line\">                    iin[v]=<span class=\"number\">1</span>;</span><br><span class=\"line\">                    q[tail]=v;</span><br><span class=\"line\">                    tail=(tail+<span class=\"number\">1</span>)%mxn;</span><br><span class=\"line\">                    cnt++;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;  <span class=\"comment\">//dis[t]即为到t的最短路（具体看点的编号）</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"Floyd-算法\"><a href=\"#Floyd-算法\" class=\"headerlink\" title=\"Floyd 算法\"></a>Floyd 算法</h2><p>用来求任意两个节点之间最短路的<strong>多源最短路算法</strong>，时间复杂度比较高为 <code>O(n^3)</code>。在需要求多源最短路的情况下可以使用。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">const</span> <span class=\"type\">int</span> mxn=<span class=\"number\">1005</span>;</span><br><span class=\"line\"><span class=\"type\">int</span> g[mxn][mxn];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">Floyd</span><span class=\"params\">(<span class=\"type\">int</span> n)</span>  <span class=\"comment\">//n为点的个数 </span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">memset</span>(g,<span class=\"number\">0x3f</span>,<span class=\"built_in\">sizeof</span>(g));</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">0</span>;i&lt;n;i++)</span><br><span class=\"line\">        g[i][i]=<span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> k=<span class=\"number\">0</span>;k&lt;n;k++)  <span class=\"comment\">//注意k要在最外面 </span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">0</span>;i&lt;n;i++)</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"type\">int</span> j=<span class=\"number\">0</span>;j&lt;n;j++)</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (g[i][j]&gt;g[i][k]+g[k][j]) g[i][j]=g[i][k]+g[k][j];</span><br><span class=\"line\">&#125;  <span class=\"comment\">//g[i][j]即为i到j的最短路</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"小结\"><a href=\"#小结\" class=\"headerlink\" title=\"小结\"></a>小结</h2><p>DIjkstra 算法是最常用的求最短路的算法，可以求出某一个点到其他点的最短路。需要注意 Dijkstra 算法的两个适用范围：</p>\n<ol>\n<li>Dijkstra 求出的是从某一个点出发的单源最短路径</li>\n<li>Dijkstra 算法要求图中不存在权值为负数的边</li>\n</ol>\n<p>如果图中存在权值为负数的边，那就需要用 Bellman-Ford 算法以及它的优化 SPFA 算法；如果需要求所有点的多源最短路径，那就需要用 Floyd 算法进行求解。</p>\n<h2 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h2><ul>\n<li><a href=\"https://oi-wiki.org/graph/shortest-path/#dijkstra-%E7%AE%97%E6%B3%95\">最短路-OI Wiki</a></li>\n</ul>\n","path":"2024/05/05/最短路算法小结/","permalink":"https://xuh723.github.io/2024/05/05/%E6%9C%80%E7%9F%AD%E8%B7%AF%E7%AE%97%E6%B3%95%E5%B0%8F%E7%BB%93/","tags":[{"name":"技术基础","_id":"clxsp136d0006igw96pg970pq","slug":"技术基础","path":"tags/技术基础/","permalink":"https://xuh723.github.io/tags/%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80/","length":5},{"name":"算法","_id":"clxsp136j000oigw9beds3z3x","slug":"算法","path":"tags/算法/","permalink":"https://xuh723.github.io/tags/%E7%AE%97%E6%B3%95/","length":1}],"categories":[],"prev":{"title":"singleflight简单介绍","date":"2024-06-24T07:56:16.000Z","slug":"singleflight简单介绍","published":true,"updated":"2024-06-24T08:05:02.212Z","_id":"clxsp136n000xigw9fhth68yq","layout":"post","photos":[],"excerpt":"","path":"2024/06/24/singleflight简单介绍/","permalink":"https://xuh723.github.io/2024/06/24/singleflight%E7%AE%80%E5%8D%95%E4%BB%8B%E7%BB%8D/","__post":true},"next":{"title":"groupcache简单介绍","date":"2024-04-28T08:15:32.000Z","slug":"groupcache简单介绍","published":true,"updated":"2024-04-28T08:20:18.535Z","_id":"clxsp136e0009igw98kcv0930","layout":"post","photos":[],"excerpt":"","path":"2024/04/28/groupcache简单介绍/","permalink":"https://xuh723.github.io/2024/04/28/groupcache%E7%AE%80%E5%8D%95%E4%BB%8B%E7%BB%8D/","__post":true},"__post":true}